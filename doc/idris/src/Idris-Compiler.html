<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/Idris/Compiler.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE PatternGuards #-}</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Idris</span><span class='hs-varop'>.</span><span class='hs-conid'>Compiler</span> <span class='hs-keyword'>where</span>
<a name="line-4"></a>
<a name="line-5"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Idris</span><span class='hs-varop'>.</span><span class='hs-conid'>AbsSyntax</span>
<a name="line-6"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Core</span><span class='hs-varop'>.</span><span class='hs-conid'>TT</span>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-comment'>{-
<a name="line-9"></a>import Idris.Transforms
<a name="line-10"></a>
<a name="line-11"></a>import Core.Evaluate
<a name="line-12"></a>import Core.CaseTree
<a name="line-13"></a>
<a name="line-14"></a>import Control.Monad.State
<a name="line-15"></a>import Data.List
<a name="line-16"></a>import System.Process
<a name="line-17"></a>import System.IO
<a name="line-18"></a>import System.Directory
<a name="line-19"></a>import System.Environment
<a name="line-20"></a>
<a name="line-21"></a>import Paths_idris
<a name="line-22"></a>
<a name="line-23"></a>import Epic.Epic hiding (Term, Type, Name, fn, compile)
<a name="line-24"></a>import qualified Epic.Epic as E
<a name="line-25"></a>-}</span>
<a name="line-26"></a>
<a name="line-27"></a><a name="compileEpic"></a><span class='hs-definition'>compileEpic</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FilePath</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Term</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Idris</span> <span class='hs-conid'>()</span>
<a name="line-28"></a><span class='hs-definition'>compileEpic</span> <span class='hs-varid'>f</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fail</span> <span class='hs-str'>"Epic backend disabled"</span>
<a name="line-29"></a>
<a name="line-30"></a><span class='hs-comment'>{-
<a name="line-31"></a>compile f tm
<a name="line-32"></a>    = do checkMVs
<a name="line-33"></a>         let tmnames = namesUsed (STerm tm)
<a name="line-34"></a>         used &lt;- mapM (allNames []) tmnames
<a name="line-35"></a>         ds &lt;- mkDecls tm (concat used)
<a name="line-36"></a>         objs &lt;- getObjectFiles
<a name="line-37"></a>         libs &lt;- getLibs
<a name="line-38"></a>         hdrs &lt;- getHdrs
<a name="line-39"></a>         ddir &lt;- liftIO $ getDataDir
<a name="line-40"></a>         -- if any includes exist in the data directory, use that
<a name="line-41"></a>         hdrs' &lt;- liftIO $ mapM (inDir ddir) hdrs
<a name="line-42"></a>         let incs = map Include hdrs'
<a name="line-43"></a>         so &lt;- getSO
<a name="line-44"></a>--          let ilib = ddir ++ "/libidris.a"
<a name="line-45"></a>         case so of
<a name="line-46"></a>            Nothing -&gt;
<a name="line-47"></a>                do m &lt;- epicMain tm
<a name="line-48"></a>                   let mainval = EpicFn (name "main") m
<a name="line-49"></a>                   liftIO $ compileObjWith [] 
<a name="line-50"></a>                                (mkProgram (incs ++ mainval : ds)) (f ++ ".o")
<a name="line-51"></a>                   liftIO $ link ((f ++ ".o") : objs ++ (map ("-l"++) libs)) f
<a name="line-52"></a>  where checkMVs = do i &lt;- get
<a name="line-53"></a>                      case idris_metavars i \\ primDefs of
<a name="line-54"></a>                            [] -&gt; return ()
<a name="line-55"></a>                            ms -&gt; fail $ "There are undefined metavariables: " ++ show ms
<a name="line-56"></a>        inDir d h = do let f = d ++ "/" ++ h
<a name="line-57"></a>                       ex &lt;- doesFileExist f
<a name="line-58"></a>                       if ex then return f else return h
<a name="line-59"></a>
<a name="line-60"></a>
<a name="line-61"></a>allNames :: [Name] -&gt; Name -&gt; Idris [Name]
<a name="line-62"></a>allNames ns n | n `elem` ns = return []
<a name="line-63"></a>allNames ns n = do i &lt;- get
<a name="line-64"></a>                   case lookupCtxt Nothing n (idris_callgraph i) of
<a name="line-65"></a>                      [ns'] -&gt; do more &lt;- mapM (allNames (n:ns)) ns' 
<a name="line-66"></a>                                  return (nub (n : concat more))
<a name="line-67"></a>                      _ -&gt; return [n]
<a name="line-68"></a>
<a name="line-69"></a>mkDecls :: Term -&gt; [Name] -&gt; Idris [EpicDecl]
<a name="line-70"></a>mkDecls t used
<a name="line-71"></a>    = do i &lt;- getIState
<a name="line-72"></a>         let ds = filter (\ (n, d) -&gt; n `elem` used) $ ctxtAlist (tt_ctxt i)
<a name="line-73"></a>         decls &lt;- mapM build ds
<a name="line-74"></a>         return $ basic_defs ++ decls
<a name="line-75"></a>             
<a name="line-76"></a>-- EpicFn (name "main") epicMain : decls
<a name="line-77"></a>
<a name="line-78"></a>ename x = name ("idris_" ++ show x)
<a name="line-79"></a>aname x = name ("a_" ++ show x)
<a name="line-80"></a>
<a name="line-81"></a>epicMain tm = do e &lt;- epic tm
<a name="line-82"></a>                 return $ effect_ e
<a name="line-83"></a>
<a name="line-84"></a>-- epicMain = effect_ $ -- ref (ename (UN "run__IO")) @@
<a name="line-85"></a>--                      ref (ename (NS (UN "main") ["main"]))
<a name="line-86"></a>
<a name="line-87"></a>class ToEpic a where
<a name="line-88"></a>    epic :: a -&gt; Idris E.Term
<a name="line-89"></a>
<a name="line-90"></a>build :: (Name, Def) -&gt; Idris EpicDecl
<a name="line-91"></a>build (n, d) = do i &lt;- getIState
<a name="line-92"></a>                  case lookup n (idris_prims i) of
<a name="line-93"></a>                    Just opDef -&gt; return $ EpicFn (ename n) opDef
<a name="line-94"></a>                    _ -&gt;       do def &lt;- epic d
<a name="line-95"></a>                                  logLvl 3 $ "Compiled " ++ show n ++ " =\n\t" ++ show def
<a name="line-96"></a>                                  return $ EpicFn (ename n) def
<a name="line-97"></a>
<a name="line-98"></a>impossible = int 42424242
<a name="line-99"></a>
<a name="line-100"></a>instance ToEpic Def where
<a name="line-101"></a>    epic (Function tm _) = epic tm
<a name="line-102"></a>    epic (CaseOp _ _ pats _ _ args sc) = epic (args, sc) -- optimised version
<a name="line-103"></a>    epic _ = return impossible
<a name="line-104"></a>
<a name="line-105"></a>instance ToEpic (TT Name) where
<a name="line-106"></a>    epic tm = epic' [] tm where
<a name="line-107"></a>      epic' env tm@(App f a)
<a name="line-108"></a>          | (P _ (UN "mkForeign") _, args) &lt;- unApply tm
<a name="line-109"></a>              = doForeign False args
<a name="line-110"></a>          | (P _ (UN "mkLazyForeign") _, args) &lt;- unApply tm
<a name="line-111"></a>              = doForeign True args
<a name="line-112"></a>          | (P _ (UN "unsafePerformIO") _, [_, arg]) &lt;- unApply tm
<a name="line-113"></a>              = epic' env arg
<a name="line-114"></a>          | (P _ (UN "lazy") _, [_,arg]) &lt;- unApply tm
<a name="line-115"></a>              = do arg' &lt;- epic' env arg
<a name="line-116"></a>                   return $ lazy_ arg'
<a name="line-117"></a>          | (P _ (UN "prim__IO") _, [v]) &lt;- unApply tm
<a name="line-118"></a>              = do v' &lt;- epic' env v
<a name="line-119"></a>                   return (effect_ v')
<a name="line-120"></a>          | (P _ (UN "io_bind") _, [_,_,v,k]) &lt;- unApply tm
<a name="line-121"></a>              = do v' &lt;- epic' env v 
<a name="line-122"></a>                   k' &lt;- epic' env k
<a name="line-123"></a>                   return (effect_ (k' @@ (effect_ v')))
<a name="line-124"></a>          | (P _ (UN "malloc") _, [_,size,t]) &lt;- unApply tm
<a name="line-125"></a>              = do size' &lt;- epic' env size
<a name="line-126"></a>                   t' &lt;- epic' env t
<a name="line-127"></a>                   return $ malloc_ size' t'
<a name="line-128"></a>          | (P _ (UN "trace_malloc") _, [_,t]) &lt;- unApply tm
<a name="line-129"></a>              = do t' &lt;- epic' env t
<a name="line-130"></a>                   return $ mallocTrace_ t'
<a name="line-131"></a>          | (P (DCon t a) n _, args) &lt;- unApply tm
<a name="line-132"></a>              = epicCon env t a n args
<a name="line-133"></a>      epic' env (P (DCon t a) n _) = return $ con_ t
<a name="line-134"></a>      epic' env (P (TCon t a) n _) = return $ con_ t
<a name="line-135"></a>      epic' env (P _ n _)          = return $ ref (ename n) 
<a name="line-136"></a>      epic' env (V i)              = return $ ref (env!!i)
<a name="line-137"></a>      epic' env (Bind n (Lam _) sc)
<a name="line-138"></a>            = do sc' &lt;- epic' (aname n : env) sc
<a name="line-139"></a>                 return $ term ([aname n], sc')
<a name="line-140"></a>      epic' env (Bind n (Let _ v) sc)
<a name="line-141"></a>            = do sc' &lt;- epic' (aname n : env) sc
<a name="line-142"></a>                 v' &lt;- epic' env v
<a name="line-143"></a>                 return $ let_ v' (aname n, sc') 
<a name="line-144"></a>      epic' env (Bind _ _ _) = return impossible
<a name="line-145"></a>      epic' env (App f a) = do f' &lt;- epic' env f
<a name="line-146"></a>                               a' &lt;- epic' env a
<a name="line-147"></a>                               return (f' @@ a')
<a name="line-148"></a>      epic' env (Constant c) = epic c
<a name="line-149"></a>      epic' env Erased       = return impossible
<a name="line-150"></a>      epic' env (TType _)      = return impossible
<a name="line-151"></a>
<a name="line-152"></a>      epicCon env t arity n args
<a name="line-153"></a>        | length args == arity = buildApp env (con_ t) args
<a name="line-154"></a>        | otherwise = let extra = satArgs (arity - length args) in
<a name="line-155"></a>                          do sc' &lt;- epicCon env t arity n 
<a name="line-156"></a>                                        (args ++ map (\n -&gt; P Bound n undefined) extra)
<a name="line-157"></a>                             return $ term (map ename extra, sc')
<a name="line-158"></a>        
<a name="line-159"></a>      satArgs n = map (\i -&gt; MN i "sat") [1..n]
<a name="line-160"></a>
<a name="line-161"></a>      buildApp env e [] = return e
<a name="line-162"></a>      buildApp env e (x:xs) = do x' &lt;- epic' env x
<a name="line-163"></a>                                 buildApp env (e @@ x') xs
<a name="line-164"></a>                                    
<a name="line-165"></a>
<a name="line-166"></a>doForeign :: Bool -&gt; [TT Name] -&gt; Idris E.Term
<a name="line-167"></a>doForeign lazy (_ : fgn : args)
<a name="line-168"></a>   | (_, (Constant (Str fgnName) : fgnArgTys : ret : [])) &lt;- unApply fgn
<a name="line-169"></a>        = let tys = getFTypes fgnArgTys
<a name="line-170"></a>              rty = mkEty' ret in
<a name="line-171"></a>              do args' &lt;- mapM epic args
<a name="line-172"></a>                 -- wrap it in a prim__IO
<a name="line-173"></a>                 -- return $ con_ 0 @@ impossible @@ 
<a name="line-174"></a>                 if lazy 
<a name="line-175"></a>                   then return $ lazy_ $ foreignL_ rty fgnName (zip args' tys)
<a name="line-176"></a>                   else return $ lazy_ $ foreign_ rty fgnName (zip args' tys)
<a name="line-177"></a>   | otherwise = fail "Badly formed foreign function call"
<a name="line-178"></a>
<a name="line-179"></a>getFTypes :: TT Name -&gt; [E.Type]
<a name="line-180"></a>getFTypes tm = case unApply tm of
<a name="line-181"></a>                 (nil, []) -&gt; []
<a name="line-182"></a>                 (cons, [ty, xs]) -&gt; 
<a name="line-183"></a>                    let rest = getFTypes xs in
<a name="line-184"></a>                        mkEty' ty : rest
<a name="line-185"></a>
<a name="line-186"></a>mkEty' (P _ (UN ty) _) = mkEty ty
<a name="line-187"></a>mkEty' _ = tyAny
<a name="line-188"></a>
<a name="line-189"></a>mkEty "FInt"    = tyInt
<a name="line-190"></a>mkEty "FFloat"  = tyFloat
<a name="line-191"></a>mkEty "FChar"   = tyChar
<a name="line-192"></a>mkEty "FString" = tyString
<a name="line-193"></a>mkEty "FPtr"    = tyPtr
<a name="line-194"></a>mkEty "FUnit"   = tyUnit
<a name="line-195"></a>
<a name="line-196"></a>instance ToEpic Const where
<a name="line-197"></a>    epic (I i)   = return (int i)
<a name="line-198"></a>    epic (BI i)  = return (bigint i)
<a name="line-199"></a>    epic (Fl f)  = return (float f)
<a name="line-200"></a>    epic (Str s) = return (str s)
<a name="line-201"></a>    epic (Ch c)  = return (char c)
<a name="line-202"></a>    epic IType   = return $ con_ 1
<a name="line-203"></a>    epic FlType  = return $ con_ 2
<a name="line-204"></a>    epic ChType  = return $ con_ 3
<a name="line-205"></a>    epic StrType = return $ con_ 4
<a name="line-206"></a>    epic PtrType = return $ con_ 5
<a name="line-207"></a>    epic BIType  = return $ con_ 6
<a name="line-208"></a>
<a name="line-209"></a>instance ToEpic ([Name], SC) where
<a name="line-210"></a>    epic (args, tree) = do logLvl 3 $ "Compiling " ++ show args ++ "\n" ++ show tree
<a name="line-211"></a>                           tree' &lt;- epic tree
<a name="line-212"></a>                           return $ term (map ename args, tree')
<a name="line-213"></a>
<a name="line-214"></a>instance ToEpic SC where
<a name="line-215"></a>    epic (Case n [ConCase _ i ns sc])
<a name="line-216"></a>        = epicLet n ns 0 sc
<a name="line-217"></a>      where
<a name="line-218"></a>        epicLet x [] _ sc = epic sc
<a name="line-219"></a>        epicLet x (n:ns) i sc 
<a name="line-220"></a>            = do sc' &lt;- epicLet x ns (i+1) sc
<a name="line-221"></a>                 return $ let_ (ref (ename x) !. i) (ename n, sc')
<a name="line-222"></a>
<a name="line-223"></a>    epic (STerm t) = epic t
<a name="line-224"></a>    epic (UnmatchedCase str) = return $ error_ str
<a name="line-225"></a>    epic (Case n alts) = do alts' &lt;- mapM mkEpicAlt alts
<a name="line-226"></a>                            return $ case_ (ref (ename n)) alts'
<a name="line-227"></a>      where
<a name="line-228"></a>        mkEpicAlt (ConCase n t args rhs) = do rhs' &lt;- epic rhs
<a name="line-229"></a>                                              return $ con t (map ename args, rhs')
<a name="line-230"></a>        mkEpicAlt (ConstCase (I i) rhs)  = do rhs' &lt;- epic rhs
<a name="line-231"></a>                                              return $ constcase i rhs'
<a name="line-232"></a>        mkEpicAlt (ConstCase IType rhs) = do rhs' &lt;- epic rhs 
<a name="line-233"></a>                                             return $ defaultcase rhs'
<a name="line-234"></a>        mkEpicAlt (ConstCase c rhs)      
<a name="line-235"></a>           = fail $ "Can only pattern match on integer constants (" ++ show c ++ ")"
<a name="line-236"></a>        mkEpicAlt (DefaultCase rhs)      = do rhs' &lt;- epic rhs
<a name="line-237"></a>                                              return $ defaultcase rhs'
<a name="line-238"></a>
<a name="line-239"></a>-}</span>
</pre></body>
</html>
