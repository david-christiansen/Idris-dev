-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Idris is a general purpose language with full dependent types. It is
--   compiled, with eager evaluation. Dependent types allow types to be
--   predicated on values, meaning that some aspects of a program's
--   behaviour can be specified precisely in the type. The language is
--   closely related to Epigram and Agda. There is a tutorial at
--   <a>http://www.idris-lang.org/documentation</a>. Features include:
--   
--   <ul>
--   <li>Full dependent types with dependent pattern matching</li>
--   <li>where clauses, with rule, simple case expressions, pattern
--   matching let and lambda bindings</li>
--   <li>Type classes, monad comprehensions</li>
--   <li>do notation, idiom brackets, syntactic conveniences for lists,
--   tuples, dependent pairs</li>
--   <li>Totality checking</li>
--   <li>Coinductive types</li>
--   <li>Indentation significant syntax, extensible syntax</li>
--   <li>Tactic based theorem proving (influenced by Coq)</li>
--   <li>Cumulative universes</li>
--   <li>Simple foreign function interface (to C)</li>
--   <li>Hugs style interactive environment</li>
--   </ul>
@package idris
@version 0.9.6.1

module Util.Pretty
class Sized a
size :: Sized a => a -> Int
breakingSize :: Int
nestingSize :: Int
class Pretty a
pretty :: Pretty a => a -> Doc
instance Pretty a => Pretty [a]
instance Pretty ()
instance Sized a => Sized [a]
instance (Sized a, Sized b) => Sized (a, b)

module Paths_idris
version :: Version
getBinDir :: IO FilePath
getLibDir :: IO FilePath
getDataDir :: IO FilePath
getLibexecDir :: IO FilePath
getDataFileName :: FilePath -> IO FilePath

module Util.System
tempfile :: IO (FilePath, Handle)
environment :: String -> IO (Maybe String)
getCC :: IO String
getLibFlags :: IO [Char]
getIdrisLibDir :: IO FilePath
getIncFlags :: IO [Char]
rmFile :: FilePath -> IO ()


-- | TT is the core language of Idris. The language has:
--   
--   <ul>
--   <li>Full dependent types</li>
--   <li>A hierarchy of universes, with cumulativity: Type : Type1, Type1 :
--   Type2, ...</li>
--   <li>Pattern matching letrec binding</li>
--   <li>(primitive types defined externally)</li>
--   </ul>
--   
--   Some technical stuff:
--   
--   <ul>
--   <li>Typechecker is kept as simple as possible - no unification, just a
--   checker for incomplete terms.</li>
--   <li>We have a simple collection of tactics which we use to elaborate
--   source programs with implicit syntax into fully explicit terms.</li>
--   </ul>
module Core.TT
data Option
TTypeInTType :: Option
CheckConv :: Option

-- | Source location. These are typically produced by the parser <a>pfc</a>
data FC
FC :: String -> Int -> FC

-- | Filename
fc_fname :: FC -> String

-- | Line number
fc_line :: FC -> Int
data Err
Msg :: String -> Err
InternalMsg :: String -> Err
CantUnify :: Bool -> Term -> Term -> Err -> [(Name, Type)] -> Int -> Err
InfiniteUnify :: Name -> Term -> [(Name, Type)] -> Err
CantConvert :: Term -> Term -> [(Name, Type)] -> Err
NoSuchVariable :: Name -> Err
NoTypeDecl :: Name -> Err
NotInjective :: Term -> Term -> Term -> Err
CantResolve :: Term -> Err
CantResolveAlts :: [String] -> Err
IncompleteTerm :: Term -> Err
UniverseError :: Err
ProgramLineComment :: Err
Inaccessible :: Name -> Err
NonCollapsiblePostulate :: Name -> Err
AlreadyDefined :: Name -> Err
ProofSearchFail :: Err -> Err
At :: FC -> Err -> Err
score :: Err -> Int
data TC a
OK :: a -> TC a
Error :: Err -> TC a
tfail :: Err -> TC a
trun :: FC -> TC a -> TC a
discard :: Monad m => m a -> m ()
showSep :: String -> [String] -> String
pmap :: (t -> t1) -> (t, t) -> (t1, t1)
traceWhen :: Bool -> String -> a -> a

-- | Names are hierarchies of strings, describing scope (so no danger of
--   duplicate names, but need to be careful on lookup).
data Name

-- | User-provided name
UN :: String -> Name

-- | Root, namespaces
NS :: Name -> [String] -> Name

-- | Machine chosen names
MN :: Int -> String -> Name

-- | Name of somethng which is never used in scope
NErased :: Name

-- | Contexts allow us to map names to things. A root name maps to a
--   collection of things in different namespaces with that name.
type Ctxt a = Map Name (Map Name a)
emptyContext :: Map k a
tcname :: Name -> Bool
implicitable :: Name -> Bool
nsroot :: Name -> Name
addDef :: Name -> a -> Ctxt a -> Ctxt a

-- | Look up a name in the context, given an optional namespace. The name
--   (n) may itself have a (partial) namespace given.
--   
--   Rules for resolution:
--   
--   <ul>
--   <li>if an explicit namespace is given, return the names which match
--   it. If none match, return all names.</li>
--   <li>if the name has has explicit namespace given, return the names
--   which match it and ignore the given namespace.</li>
--   <li>otherwise, return all names.</li>
--   </ul>
lookupCtxtName :: Maybe [String] -> Name -> Ctxt a -> [(Name, a)]
lookupCtxt :: Maybe [String] -> Name -> Ctxt a -> [a]
updateDef :: Name -> (a -> a) -> Ctxt a -> Ctxt a
toAlist :: Ctxt a -> [(Name, a)]
addAlist :: Show a => [(Name, a)] -> Ctxt a -> Ctxt a
data Const
I :: Int -> Const
BI :: Integer -> Const
Fl :: Double -> Const
Ch :: Char -> Const
Str :: String -> Const
IType :: Const
BIType :: Const
FlType :: Const
ChType :: Const
StrType :: Const
B8 :: Word8 -> Const
B16 :: Word16 -> Const
B32 :: Word32 -> Const
B64 :: Word64 -> Const
B8Type :: Const
B16Type :: Const
B32Type :: Const
B64Type :: Const
PtrType :: Const
VoidType :: Const
Forgot :: Const
data Raw
Var :: Name -> Raw
RBind :: Name -> (Binder Raw) -> Raw -> Raw
RApp :: Raw -> Raw -> Raw
RType :: Raw
RForce :: Raw -> Raw
RConstant :: Const -> Raw

-- | All binding forms are represented in a unform fashion.
data Binder b
Lam :: b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b
Pi :: b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b
Let :: b -> b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b

-- | value for bound variable
binderVal :: Binder b -> b
NLet :: b -> b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b

-- | value for bound variable
binderVal :: Binder b -> b
Hole :: b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b
GHole :: b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b
Guess :: b -> b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b

-- | value for bound variable
binderVal :: Binder b -> b
PVar :: b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b
PVTy :: b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b
fmapMB :: Monad m => (a -> m b) -> Binder a -> m (Binder b)
raw_apply :: Raw -> [Raw] -> Raw
raw_unapply :: Raw -> (Raw, [Raw])
data RawFun
RawFun :: Raw -> Raw -> RawFun
rtype :: RawFun -> Raw
rval :: RawFun -> Raw
data RawDatatype
RDatatype :: Name -> Raw -> [(Name, Raw)] -> RawDatatype
data RDef
RFunction :: RawFun -> RDef
RConst :: Raw -> RDef
RData :: RawDatatype -> RDef
type RProgram = [(Name, RDef)]

-- | Universe expressions for universe checking
data UExp

-- | universe variable
UVar :: Int -> UExp

-- | explicit universe level
UVal :: Int -> UExp

-- | Universe constraints
data UConstraint

-- | Strictly less than
ULT :: UExp -> UExp -> UConstraint

-- | Less than or equal to
ULE :: UExp -> UExp -> UConstraint
type UCs = (Int, [UConstraint])
data NameType
Bound :: NameType
Ref :: NameType
DCon :: Int -> Int -> NameType
TCon :: Int -> Int -> NameType

-- | Terms in the core language
data TT n

-- | embed type
P :: NameType -> n -> (TT n) -> TT n

-- | a variable (de Bruijn-indexed)
V :: Int -> TT n

-- | a binding
Bind :: n -> (Binder (TT n)) -> (TT n) -> TT n

-- | function, function type, arg
App :: (TT n) -> (TT n) -> TT n

-- | constant
Constant :: Const -> TT n

-- | argument projection; runtime only
Proj :: (TT n) -> Int -> TT n

-- | an erased term
Erased :: TT n

-- | special case for totality checking
Impossible :: TT n

-- | the type of types at some level
TType :: UExp -> TT n
class TermSize a
termsize :: TermSize a => Name -> a -> Int
type EnvTT n = [(n, Binder (TT n))]
data Datatype n
Data :: n -> Int -> (TT n) -> [(n, TT n)] -> Datatype n
d_typename :: Datatype n -> n
d_typetag :: Datatype n -> Int
d_type :: Datatype n -> (TT n)
d_cons :: Datatype n -> [(n, TT n)]

-- | A term is injective iff it is a data constructor, type constructor,
--   constant, the type Type, pi-binding, or an application of an injective
--   term.
isInjective :: TT n -> Bool

-- | Count the number of instances of a de Bruijn index in a term
vinstances :: Int -> TT n -> Int
instantiate :: TT n -> TT n -> TT n
explicitNames :: TT n -> TT n
pToV :: Eq n => n -> TT n -> TT n
pToV' :: Eq n => n -> Int -> TT n -> TT n

-- | Convert several names. First in the list comes out as V 0
pToVs :: Eq n => [n] -> TT n -> TT n
vToP :: TT n -> TT n
finalise :: Eq n => TT n -> TT n
subst :: Eq n => n -> TT n -> TT n -> TT n
substNames :: Eq n => [(n, TT n)] -> TT n -> TT n
substTerm :: Eq n => TT n -> TT n -> TT n -> TT n
noOccurrence :: Eq n => n -> TT n -> Bool

-- | Returns all names used free in the term
freeNames :: Eq n => TT n -> [n]

-- | Return the arity of a (normalised) type
arity :: TT n -> Int

-- | Deconstruct an application; returns the function and a list of
--   arguments
unApply :: TT n -> (TT n, [TT n])
mkApp :: TT n -> [TT n] -> TT n
forget :: TT Name -> Raw
bindAll :: [(n, Binder (TT n))] -> TT n -> TT n
bindTyArgs :: (TT n -> Binder (TT n)) -> [(n, TT n)] -> TT n -> TT n
getArgTys :: TT n -> [(n, TT n)]
getRetTy :: TT n -> TT n
uniqueName :: Name -> [Name] -> Name
uniqueBinders :: [Name] -> TT Name -> TT Name
nextName :: Name -> Name
type Term = TT Name
type Type = Term
type Env = EnvTT Name
newtype WkEnvTT n
Wk :: (EnvTT n) -> WkEnvTT n
type WkEnv = WkEnvTT Name
showEnv :: (Eq a, Show a) => [(a, Binder (TT a))] -> TT a -> [Char]
showEnvDbg :: (Eq a, Show a) => [(a, Binder (TT a))] -> TT a -> [Char]
prettyEnv :: (Eq a, Show a, Pretty a) => [(a, Binder (TT a))] -> TT a -> Doc
showEnv' :: (Eq a, Show a) => [(a, Binder (TT a))] -> TT a -> Bool -> [Char]

-- | Check whether a term has any holes in it - impure if so
pureTerm :: TT Name -> Bool

-- | Weaken a term by adding i to each de Bruijn index (i.e. lift it over i
--   bindings)
weakenTm :: Int -> TT n -> TT n

-- | Weaken an environment so that all the de Bruijn indices are correct
--   according to the latest bound variable
weakenEnv :: EnvTT n -> EnvTT n
weakenTmEnv :: Int -> EnvTT n -> EnvTT n
orderPats :: Term -> Term
instance Eq Option
instance Eq FC
instance Eq Name
instance Ord Name
instance Eq Const
instance Ord Const
instance Show b => Show (Binder b)
instance Eq b => Eq (Binder b)
instance Ord b => Ord (Binder b)
instance Functor Binder
instance Show Raw
instance Eq Raw
instance Show RawFun
instance Show RawDatatype
instance Show RDef
instance Eq UExp
instance Ord UExp
instance Eq UConstraint
instance Show NameType
instance Ord NameType
instance Ord n => Ord (TT n)
instance Functor TT
instance (Eq n, Show n) => Show (Datatype n)
instance Functor Datatype
instance Eq n => Eq (Datatype n)
instance Eq Err
instance Eq a => Eq (TC a)
instance Functor TC
instance Show Const
instance (Eq n, Show n) => Show (TT n)
instance Eq n => Eq (TT n)
instance Pretty a => Pretty (TT a)
instance Sized a => Sized (TT a)
instance TermSize (TT Name)
instance TermSize a => TermSize [a]
instance Eq NameType
instance Pretty NameType
instance Sized NameType
instance Show UConstraint
instance Show UExp
instance Binary UExp
instance Sized UExp
instance Sized a => Sized (Binder a)
instance Pretty Raw
instance Sized Raw
instance Pretty Const
instance Sized Const
instance Show Name
instance Pretty Name
instance Sized Name
instance MonadPlus TC
instance Monad TC
instance Show a => Show (TC a)
instance Pretty a => Pretty (TC a)
instance Pretty Err
instance Show Err
instance Sized Err
instance Show FC
instance Sized FC


-- | Check universe constraints.
module Core.Constraints

-- | Check that a list of universe constraints can be satisfied.
ucheck :: [(UConstraint, FC)] -> TC ()

module Core.CaseTree
data CaseDef
CaseDef :: [Name] -> SC -> [Term] -> CaseDef
type SC = SC' Term
data SC' t
Case :: Name -> [CaseAlt' t] -> SC' t
ProjCase :: t -> [CaseAlt' t] -> SC' t
STerm :: t -> SC' t
UnmatchedCase :: String -> SC' t
ImpossibleCase :: SC' t
type CaseAlt = CaseAlt' Term
data CaseAlt' t
ConCase :: Name -> Int -> [Name] -> (SC' t) -> CaseAlt' t
ConstCase :: Const -> (SC' t) -> CaseAlt' t
DefaultCase :: (SC' t) -> CaseAlt' t
data Phase
CompileTime :: Phase
RunTime :: Phase
type CaseTree = SC
simpleCase :: Bool -> Bool -> Phase -> FC -> [([Name], Term, Term)] -> TC CaseDef
small :: Name -> [Name] -> SC -> Bool
namesUsed :: SC -> [Name]
findCalls :: SC -> [Name] -> [(Name, [[Name]])]
findUsedArgs :: SC -> [Name] -> [Name]
instance Show t => Show (CaseAlt' t)
instance Eq t => Eq (CaseAlt' t)
instance Ord t => Ord (CaseAlt' t)
instance Functor CaseAlt'
instance Eq t => Eq (SC' t)
instance Ord t => Ord (SC' t)
instance Functor SC'
instance Show CaseDef
instance Show Phase
instance Eq Phase
instance Show Pat
instance Show Partition
instance TermSize CaseAlt
instance TermSize SC
instance Show t => Show (SC' t)

module Core.Evaluate
normalise :: Context -> Env -> TT Name -> TT Name
normaliseTrace :: Bool -> Context -> Env -> TT Name -> TT Name

-- | Normalise fully type checked terms (so, assume all names/let bindings
--   resolved)
normaliseC :: Context -> Env -> TT Name -> TT Name
normaliseAll :: Context -> Env -> TT Name -> TT Name

-- | Like normalise, but we only reduce functions that are marked as okay
--   to inline (and probably shouldn't reduce lets?)
simplify :: Context -> Bool -> Env -> TT Name -> TT Name
specialise :: Context -> Env -> [(Name, Int)] -> TT Name -> TT Name

-- | Reduce a term to head normal form
hnf :: Context -> Env -> TT Name -> TT Name
convEq :: Context -> TT Name -> TT Name -> StateT UCs TC Bool
convEq' :: Context -> TT Name -> TT Name -> TC Bool

-- | A definition is either a simple function (just an expression with a
--   type), a constant, which could be a data or type constructor, an axiom
--   or as an yet undefined function, or an Operator. An Operator is a
--   function which explains how to reduce. A CaseOp is a function defined
--   by a simple case tree
data Def
Function :: Type -> Term -> Def
TyDecl :: NameType -> Type -> Def
Operator :: Type -> Int -> ([Value] -> Maybe Value) -> Def
CaseOp :: Bool -> Bool -> Type -> [Either Term (Term, Term)] -> [([Name], Term, Term)] -> [Name] -> SC -> [Name] -> SC -> Def
data Accessibility
Public :: Accessibility
Frozen :: Accessibility
Hidden :: Accessibility

-- | The result of totality checking
data Totality

-- | well-founded arguments
Total :: [Int] -> Totality

-- | productive
Productive :: Totality
Partial :: PReason -> Totality
Unchecked :: Totality

-- | Reasons why a function may not be total
data PReason
Other :: [Name] -> PReason
Itself :: PReason
NotCovering :: PReason
NotPositive :: PReason
UseUndef :: Name -> PReason
BelieveMe :: PReason
Mutual :: [Name] -> PReason
NotProductive :: PReason

-- | Contexts used for global definitions and for proof state. They contain
--   universe constraints and existing definitions.
data Context

-- | The initial empty context
initContext :: Context

-- | Get the definitions from a context
ctxtAlist :: Context -> [(Name, Def)]
uconstraints :: Context -> [UConstraint]
next_tvar :: Context -> Int
addToCtxt :: Name -> Term -> Type -> Context -> Context
setAccess :: Name -> Accessibility -> Context -> Context
setTotal :: Name -> Totality -> Context -> Context
addCtxtDef :: Name -> Def -> Context -> Context
addTyDecl :: Name -> Type -> Context -> Context
addDatatype :: Datatype Name -> Context -> Context
addCasedef :: Name -> Bool -> Bool -> Bool -> Bool -> [Either Term (Term, Term)] -> [([Name], Term, Term)] -> [([Name], Term, Term)] -> Type -> Context -> Context
simplifyCasedef :: Name -> Context -> Context
addOperator :: Name -> Type -> Int -> ([Value] -> Maybe Value) -> Context -> Context
lookupNames :: Maybe [String] -> Name -> Context -> [Name]
lookupTy :: Maybe [String] -> Name -> Context -> [Type]
lookupP :: Maybe [String] -> Name -> Context -> [Term]
lookupDef :: Maybe [String] -> Name -> Context -> [Def]
lookupVal :: Maybe [String] -> Name -> Context -> [Value]
lookupTotal :: Name -> Context -> [Totality]
lookupTyEnv :: Name -> Env -> Maybe (Int, Type)
isConName :: Maybe [String] -> Name -> Context -> Bool
isFnName :: Maybe [String] -> Name -> Context -> Bool

-- | A HOAS representation of values
data Value
VP :: NameType -> Name -> Value -> Value
VV :: Int -> Value
VBind :: Name -> (Binder Value) -> (Value -> Eval Value) -> Value
VApp :: Value -> Value -> Value
VType :: UExp -> Value
VErased :: Value
VConstant :: Const -> Value
VTmp :: Int -> Value
instance Show EvalOpt
instance Eq EvalOpt
instance Show HNF
instance Show Accessibility
instance Eq Accessibility
instance Show PReason
instance Eq PReason
instance Eq Totality
instance Show Totality
instance Binary (a -> b)
instance Show Def
instance Quote HNF
instance Quote Value
instance Show (a -> b)
instance Show Value

module Core.Typecheck
convertsC :: Context -> Env -> Term -> Term -> StateT UCs TC ()
converts :: Context -> Env -> Term -> Term -> TC ()
errEnv :: [(t, Binder t1)] -> [(t, t1)]
isType :: Context -> Env -> Term -> TC ()
recheck :: Context -> Env -> Raw -> Term -> TC (Term, Type, UCs)
check :: Context -> Env -> Raw -> TC (Term, Type)
check' :: Bool -> Context -> Env -> Raw -> StateT UCs TC (Term, Type)
checkProgram :: Context -> RProgram -> TC Context

module Core.Unify
unify :: Context -> Env -> TT Name -> TT Name -> [Name] -> [Name] -> TC ([(Name, TT Name)], Fails)
type Fails = [(TT Name, TT Name, Env, Err)]
instance Show UInfo

module Core.ProofState
data ProofState
PS :: Name -> [Name] -> [Name] -> Int -> Term -> Type -> [Name] -> (Name, [(Name, Term)]) -> Maybe (Name, Term) -> Fails -> [Name] -> [Name] -> [Name] -> Maybe ProofState -> Context -> String -> Bool -> ProofState
thname :: ProofState -> Name
holes :: ProofState -> [Name]
usedns :: ProofState -> [Name]
nextname :: ProofState -> Int
pterm :: ProofState -> Term
ptype :: ProofState -> Type
dontunify :: ProofState -> [Name]
unified :: ProofState -> (Name, [(Name, Term)])
solved :: ProofState -> Maybe (Name, Term)
problems :: ProofState -> Fails
injective :: ProofState -> [Name]
deferred :: ProofState -> [Name]
instances :: ProofState -> [Name]
previous :: ProofState -> Maybe ProofState
context :: ProofState -> Context
plog :: ProofState -> String
done :: ProofState -> Bool
newProof :: Name -> Context -> Type -> ProofState
envAtFocus :: ProofState -> TC Env
goalAtFocus :: ProofState -> TC (Binder Type)
data Tactic
Attack :: Tactic
Claim :: Name -> Raw -> Tactic
Reorder :: Name -> Tactic
Exact :: Raw -> Tactic
Fill :: Raw -> Tactic
PrepFill :: Name -> [Name] -> Tactic
CompleteFill :: Tactic
Regret :: Tactic
Solve :: Tactic
StartUnify :: Name -> Tactic
EndUnify :: Tactic
Compute :: Tactic
HNF_Compute :: Tactic
EvalIn :: Raw -> Tactic
CheckIn :: Raw -> Tactic
Intro :: (Maybe Name) -> Tactic
IntroTy :: Raw -> (Maybe Name) -> Tactic
Forall :: Name -> Raw -> Tactic
LetBind :: Name -> Raw -> Raw -> Tactic
Rewrite :: Raw -> Tactic
PatVar :: Name -> Tactic
PatBind :: Name -> Tactic
Focus :: Name -> Tactic
Defer :: Name -> Tactic
DeferType :: Name -> Raw -> [Name] -> Tactic
Instance :: Name -> Tactic
SetInjective :: Name -> Tactic
MoveLast :: Name -> Tactic
ProofState :: Tactic
Undo :: Tactic
QED :: Tactic
data Goal
GD :: Env -> Binder Term -> Goal
premises :: Goal -> Env
goalType :: Goal -> Binder Term
processTactic :: Tactic -> ProofState -> TC (ProofState, String)
dropGiven :: Eq a => [a] -> [(a, TT a)] -> [a] -> [(a, TT a)]
instance Show Tactic
instance Pretty ProofState
instance Show ProofState

module Core.Elaborate
data Command
Theorem :: Name -> Raw -> Command
Eval :: Raw -> Command
Quit :: Command
Print :: Name -> Command
Tac :: (Elab ()) -> Command
data ElabState aux
ES :: (ProofState, aux) -> String -> (Maybe (ElabState aux)) -> ElabState aux
type Elab' aux a = StateT (ElabState aux) TC a
type Elab a = Elab' () a
proof :: ElabState aux -> ProofState
proofFail :: Elab' aux a -> Elab' aux a
saveState :: Elab' aux ()
loadState :: Elab' aux ()
erun :: FC -> Elab' aux a -> Elab' aux a
runElab :: aux -> Elab' aux a -> ProofState -> TC (a, ElabState aux)
execElab :: aux -> Elab' aux a -> ProofState -> TC (ElabState aux)
initElaborator :: Name -> Context -> Type -> ProofState
elaborate :: Context -> Name -> Type -> aux -> Elab' aux a -> TC (a, String)
updateAux :: (aux -> aux) -> Elab' aux ()
getAux :: Elab' aux aux
processTactic' :: (MonadTrans t, MonadState (ElabState aux) (t TC)) => Tactic -> t TC ()
get_context :: Elab' aux Context
set_context :: Context -> Elab' aux ()
get_term :: Elab' aux Term
update_term :: (Term -> Term) -> Elab' aux ()
get_env :: Elab' aux Env
get_holes :: Elab' aux [Name]
get_probs :: Elab' aux Fails
goal :: Elab' aux Type
get_guess :: Elab' aux Type
get_type :: Raw -> Elab' aux Type
get_type_val :: Raw -> Elab' aux (Term, Type)
get_deferred :: Elab' aux [Name]
checkInjective :: (Term, Term, Term) -> Elab' aux ()
get_instances :: Elab' aux [Name]
unique_hole :: Name -> Elab' aux Name
unique_hole' :: Bool -> Name -> Elab' aux Name
uniqueNameCtxt :: Context -> Name -> [Name] -> Elab' aux Name
elog :: String -> Elab' aux ()
getLog :: Elab' aux String
attack :: Elab' aux ()
claim :: Name -> Raw -> Elab' aux ()
exact :: Raw -> Elab' aux ()
fill :: Raw -> Elab' aux ()
prep_fill :: Name -> [Name] -> Elab' aux ()
complete_fill :: Elab' aux ()
solve :: Elab' aux ()
start_unify :: Name -> Elab' aux ()
end_unify :: Elab' aux ()
regret :: Elab' aux ()
compute :: Elab' aux ()
hnf_compute :: Elab' aux ()
eval_in :: Raw -> Elab' aux ()
check_in :: Raw -> Elab' aux ()
intro :: Maybe Name -> Elab' aux ()
introTy :: Raw -> Maybe Name -> Elab' aux ()
forall :: Name -> Raw -> Elab' aux ()
letbind :: Name -> Raw -> Raw -> Elab' aux ()
rewrite :: Raw -> Elab' aux ()
patvar :: Name -> Elab' aux ()
patbind :: Name -> Elab' aux ()
focus :: Name -> Elab' aux ()
movelast :: Name -> Elab' aux ()
defer :: Name -> Elab' aux ()
deferType :: Name -> Raw -> [Name] -> Elab' aux ()
instanceArg :: Name -> Elab' aux ()
setinj :: Name -> Elab' aux ()
proofstate :: Elab' aux ()
reorder_claims :: Name -> Elab' aux ()
qed :: Elab' aux Term
undo :: Elab' aux ()
prepare_apply :: Raw -> [Bool] -> Elab' aux [Name]
apply :: Raw -> [(Bool, Int)] -> Elab' aux [Name]
apply2 :: Raw -> [Maybe (Elab' aux ())] -> Elab' aux ()
apply_elab :: Name -> [Maybe (Int, Elab' aux ())] -> Elab' aux ()
simple_app :: Elab' aux () -> Elab' aux () -> Elab' aux ()
arg :: Name -> Name -> Elab' aux ()
try :: Elab' aux a -> Elab' aux a -> Elab' aux a
try' :: Elab' aux a -> Elab' aux a -> Bool -> Elab' aux a
tryWhen :: Bool -> Elab' aux a -> Elab' aux a -> Elab' aux a
tryAll :: [(Elab' aux a, String)] -> Elab' aux a
prunStateT :: [a] -> StateT (ElabState t) TC t1 -> ElabState t -> TC (t1, ElabState t)
dumpprobs :: Show a => [(t, t1, t2, a)] -> [Char]
instance Show aux => Show (ElabState aux)

module IRTS.Lang
data LVar
Loc :: Int -> LVar
Glob :: Name -> LVar
data LExp
LV :: LVar -> LExp
LApp :: Bool -> LExp -> [LExp] -> LExp
LLazyApp :: Name -> [LExp] -> LExp
LLazyExp :: LExp -> LExp
LForce :: LExp -> LExp
LLet :: Name -> LExp -> LExp -> LExp
LLam :: [Name] -> LExp -> LExp
LProj :: LExp -> Int -> LExp
LCon :: Int -> Name -> [LExp] -> LExp
LCase :: LExp -> [LAlt] -> LExp
LConst :: Const -> LExp
LForeign :: FLang -> FType -> String -> [(FType, LExp)] -> LExp
LOp :: PrimFn -> [LExp] -> LExp
LNothing :: LExp
LError :: String -> LExp
data PrimFn
LPlus :: PrimFn
LMinus :: PrimFn
LTimes :: PrimFn
LDiv :: PrimFn
LMod :: PrimFn
LAnd :: PrimFn
LOr :: PrimFn
LXOr :: PrimFn
LCompl :: PrimFn
LSHL :: PrimFn
LSHR :: PrimFn
LEq :: PrimFn
LLt :: PrimFn
LLe :: PrimFn
LGt :: PrimFn
LGe :: PrimFn
LFPlus :: PrimFn
LFMinus :: PrimFn
LFTimes :: PrimFn
LFDiv :: PrimFn
LFEq :: PrimFn
LFLt :: PrimFn
LFLe :: PrimFn
LFGt :: PrimFn
LFGe :: PrimFn
LBPlus :: PrimFn
LBMinus :: PrimFn
LBDec :: PrimFn
LBTimes :: PrimFn
LBDiv :: PrimFn
LBMod :: PrimFn
LBEq :: PrimFn
LBLt :: PrimFn
LBLe :: PrimFn
LBGt :: PrimFn
LBGe :: PrimFn
LStrConcat :: PrimFn
LStrLt :: PrimFn
LStrEq :: PrimFn
LStrLen :: PrimFn
LIntFloat :: PrimFn
LFloatInt :: PrimFn
LIntStr :: PrimFn
LStrInt :: PrimFn
LFloatStr :: PrimFn
LStrFloat :: PrimFn
LIntBig :: PrimFn
LBigInt :: PrimFn
LStrBig :: PrimFn
LBigStr :: PrimFn
LChInt :: PrimFn
LIntCh :: PrimFn
LPrintNum :: PrimFn
LPrintStr :: PrimFn
LReadStr :: PrimFn
LB8Lt :: PrimFn
LB8Lte :: PrimFn
LB8Eq :: PrimFn
LB8Gt :: PrimFn
LB8Gte :: PrimFn
LB8Plus :: PrimFn
LB8Minus :: PrimFn
LB8Times :: PrimFn
LB8UDiv :: PrimFn
LB8SDiv :: PrimFn
LB8URem :: PrimFn
LB8SRem :: PrimFn
LB8Shl :: PrimFn
LB8LShr :: PrimFn
LB8AShr :: PrimFn
LB8And :: PrimFn
LB8Or :: PrimFn
LB8Xor :: PrimFn
LB8Compl :: PrimFn
LB8Z16 :: PrimFn
LB8Z32 :: PrimFn
LB8Z64 :: PrimFn
LB8S16 :: PrimFn
LB8S32 :: PrimFn
LB8S64 :: PrimFn
LB16Lt :: PrimFn
LB16Lte :: PrimFn
LB16Eq :: PrimFn
LB16Gt :: PrimFn
LB16Gte :: PrimFn
LB16Plus :: PrimFn
LB16Minus :: PrimFn
LB16Times :: PrimFn
LB16UDiv :: PrimFn
LB16SDiv :: PrimFn
LB16URem :: PrimFn
LB16SRem :: PrimFn
LB16Shl :: PrimFn
LB16LShr :: PrimFn
LB16AShr :: PrimFn
LB16And :: PrimFn
LB16Or :: PrimFn
LB16Xor :: PrimFn
LB16Compl :: PrimFn
LB16Z32 :: PrimFn
LB16Z64 :: PrimFn
LB16S32 :: PrimFn
LB16S64 :: PrimFn
LB16T8 :: PrimFn
LB32Lt :: PrimFn
LB32Lte :: PrimFn
LB32Eq :: PrimFn
LB32Gt :: PrimFn
LB32Gte :: PrimFn
LB32Plus :: PrimFn
LB32Minus :: PrimFn
LB32Times :: PrimFn
LB32UDiv :: PrimFn
LB32SDiv :: PrimFn
LB32URem :: PrimFn
LB32SRem :: PrimFn
LB32Shl :: PrimFn
LB32LShr :: PrimFn
LB32AShr :: PrimFn
LB32And :: PrimFn
LB32Or :: PrimFn
LB32Xor :: PrimFn
LB32Compl :: PrimFn
LB32Z64 :: PrimFn
LB32S64 :: PrimFn
LB32T8 :: PrimFn
LB32T16 :: PrimFn
LB64Lt :: PrimFn
LB64Lte :: PrimFn
LB64Eq :: PrimFn
LB64Gt :: PrimFn
LB64Gte :: PrimFn
LB64Plus :: PrimFn
LB64Minus :: PrimFn
LB64Times :: PrimFn
LB64UDiv :: PrimFn
LB64SDiv :: PrimFn
LB64URem :: PrimFn
LB64SRem :: PrimFn
LB64Shl :: PrimFn
LB64LShr :: PrimFn
LB64AShr :: PrimFn
LB64And :: PrimFn
LB64Or :: PrimFn
LB64Xor :: PrimFn
LB64Compl :: PrimFn
LB64T8 :: PrimFn
LB64T16 :: PrimFn
LB64T32 :: PrimFn
LIntB8 :: PrimFn
LIntB16 :: PrimFn
LIntB32 :: PrimFn
LIntB64 :: PrimFn
LB32Int :: PrimFn
LFExp :: PrimFn
LFLog :: PrimFn
LFSin :: PrimFn
LFCos :: PrimFn
LFTan :: PrimFn
LFASin :: PrimFn
LFACos :: PrimFn
LFATan :: PrimFn
LFSqrt :: PrimFn
LFFloor :: PrimFn
LFCeil :: PrimFn
LStrHead :: PrimFn
LStrTail :: PrimFn
LStrCons :: PrimFn
LStrIndex :: PrimFn
LStrRev :: PrimFn
LStdIn :: PrimFn
LStdOut :: PrimFn
LStdErr :: PrimFn
LFork :: PrimFn
LPar :: PrimFn
LVMPtr :: PrimFn
LNoOp :: PrimFn
data FLang
LANG_C :: FLang
data FType
FInt :: FType
FChar :: FType
FString :: FType
FUnit :: FType
FPtr :: FType
FDouble :: FType
FAny :: FType
data LAlt
LConCase :: Int -> Name -> [Name] -> LExp -> LAlt
LConstCase :: Const -> LExp -> LAlt
LDefaultCase :: LExp -> LAlt
data LDecl
LFun :: [LOpt] -> Name -> [Name] -> LExp -> LDecl
LConstructor :: Name -> Int -> Int -> LDecl
type LDefs = Ctxt LDecl
data LOpt
Inline :: LOpt
NoInline :: LOpt
addTags :: Int -> [(Name, LDecl)] -> (Int, [(Name, LDecl)])
data LiftState
LS :: Name -> Int -> [(Name, LDecl)] -> LiftState
lname :: Name -> Int -> Name
liftAll :: [(Name, LDecl)] -> [(Name, LDecl)]
lambdaLift :: Name -> LDecl -> [(Name, LDecl)]
getNextName :: State LiftState Name
addFn :: Name -> LDecl -> State LiftState ()
lift :: [Name] -> LExp -> State LiftState LExp
usedArg :: Eq t => [t] -> t -> [t]
usedIn :: [Name] -> LExp -> [Name]
instance Show LVar
instance Eq LVar
instance Show PrimFn
instance Eq PrimFn
instance Show FLang
instance Eq FLang
instance Show FType
instance Eq FType
instance Show LAlt
instance Eq LAlt
instance Eq LExp
instance Show LOpt
instance Eq LOpt
instance Show LDecl
instance Eq LDecl
instance Show LExp

module Idris.Unlit
unlit :: FilePath -> String -> TC String

module IRTS.Defunctionalise
data DExp
DV :: LVar -> DExp
DApp :: Bool -> Name -> [DExp] -> DExp
DLet :: Name -> DExp -> DExp -> DExp
DUpdate :: Name -> DExp -> DExp
DProj :: DExp -> Int -> DExp
DC :: Int -> Name -> [DExp] -> DExp
DCase :: DExp -> [DAlt] -> DExp
DChkCase :: DExp -> [DAlt] -> DExp
DConst :: Const -> DExp
DForeign :: FLang -> FType -> String -> [(FType, DExp)] -> DExp
DOp :: PrimFn -> [DExp] -> DExp
DNothing :: DExp
DError :: String -> DExp
data DAlt
DConCase :: Int -> Name -> [Name] -> DExp -> DAlt
DConstCase :: Const -> DExp -> DAlt
DDefaultCase :: DExp -> DAlt
data DDecl
DFun :: Name -> [Name] -> DExp -> DDecl
DConstructor :: Name -> Int -> Int -> DDecl
type DDefs = Ctxt DDecl
defunctionalise :: Int -> LDefs -> DDefs
getFn :: [(Name, LDecl)] -> [(Name, Int)]
addApps :: LDefs -> (Name, LDecl) -> State [Name] (Name, DDecl)
eEVAL :: DExp -> DExp
data EvalApply a
EvalCase :: (Name -> a) -> EvalApply a
ApplyCase :: a -> EvalApply a
toCons :: [Name] -> (Name, Int) -> [(Name, Int, EvalApply DAlt)]
mkApplyCase :: Name -> Int -> Int -> [(Name, Int, EvalApply DAlt)]
mkEval :: [(Name, Int, EvalApply DAlt)] -> (Name, DDecl)
mkApply :: [(Name, Int, EvalApply DAlt)] -> (Name, DDecl)
declare :: Int -> [(Name, Int, EvalApply DAlt)] -> [(Name, DDecl)]
genArgs :: Int -> [Name]
mkFnCon :: Show a => a -> Name
mkUnderCon :: Name -> Int -> Name
mkBigCase :: t -> Int -> DExp -> [DAlt] -> DExp
groupsOf :: Int -> [DAlt] -> [[DAlt]]
dumpDefuns :: DDefs -> String
instance Show DAlt
instance Eq DAlt
instance Eq DExp
instance Show DDecl
instance Eq DDecl
instance Show DExp

module IRTS.Simplified
data SExp
SV :: LVar -> SExp
SApp :: Bool -> Name -> [LVar] -> SExp
SLet :: LVar -> SExp -> SExp -> SExp
SUpdate :: LVar -> SExp -> SExp
SCon :: Int -> Name -> [LVar] -> SExp
SCase :: LVar -> [SAlt] -> SExp
SChkCase :: LVar -> [SAlt] -> SExp
SProj :: LVar -> Int -> SExp
SConst :: Const -> SExp
SForeign :: FLang -> FType -> String -> [(FType, LVar)] -> SExp
SOp :: PrimFn -> [LVar] -> SExp
SNothing :: SExp
SError :: String -> SExp
data SAlt
SConCase :: Int -> Int -> Name -> [Name] -> SExp -> SAlt
SConstCase :: Const -> SExp -> SAlt
SDefaultCase :: SExp -> SAlt
data SDecl
SFun :: Name -> [Name] -> Int -> SExp -> SDecl
hvar :: State (DDefs, Int) Int
ldefs :: State (DDefs, Int) DDefs
simplify :: Bool -> DExp -> State (DDefs, Int) SExp
sVar :: DExp -> StateT (DDefs, Int) Identity (LVar, Maybe SExp)
mkapp :: Monad m => ([LVar] -> SExp) -> [(LVar, Maybe SExp)] -> m SExp
mkfapp :: Monad m => ([(t, LVar)] -> SExp) -> [(t, (LVar, Maybe SExp))] -> m SExp
sAlt :: Bool -> DAlt -> StateT (DDefs, Int) Identity SAlt
checkDefs :: DDefs -> [(Name, DDecl)] -> TC [(Name, SDecl)]
lvar :: (Ord s, MonadState s m) => s -> m ()
scopecheck :: DDefs -> [(Name, Int)] -> SExp -> StateT Int TC SExp
instance Show SAlt
instance Show SExp
instance Show SDecl

module IRTS.CodegenCommon
data DbgLevel
NONE :: DbgLevel
DEBUG :: DbgLevel
TRACE :: DbgLevel
data OutputType
Raw :: OutputType
Object :: OutputType
Executable :: OutputType
environment :: String -> IO (Maybe String)
instance Eq DbgLevel
instance Eq OutputType
instance Show OutputType

module Idris.AbsSyntaxTree
data IOption
IOption :: Int -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Target -> OutputType -> FilePath -> [FilePath] -> [Opt] -> IOption
opt_logLevel :: IOption -> Int
opt_typecase :: IOption -> Bool
opt_typeintype :: IOption -> Bool
opt_coverage :: IOption -> Bool
opt_showimp :: IOption -> Bool
opt_errContext :: IOption -> Bool
opt_repl :: IOption -> Bool
opt_verbose :: IOption -> Bool
opt_target :: IOption -> Target
opt_outputTy :: IOption -> OutputType
opt_ibcsubdir :: IOption -> FilePath
opt_importdirs :: IOption -> [FilePath]
opt_cmdline :: IOption -> [Opt]
defaultOpts :: IOption

-- | The global state used in the Idris monad
data IState
IState :: Context -> [(UConstraint, FC)] -> [FixDecl] -> Ctxt [PArg] -> Ctxt [Bool] -> Ctxt ClassInfo -> Ctxt DSL -> Ctxt OptInfo -> Ctxt TypeInfo -> Ctxt [([Name], Term, Term)] -> Ctxt [FnOpt] -> Ctxt CGInfo -> Ctxt [Name] -> Ctxt String -> [(FC, Name)] -> String -> IOption -> Int -> [Name] -> [Name] -> [Syntax] -> [String] -> [FilePath] -> [(Name, (Int, PrimFn))] -> [FilePath] -> [String] -> [String] -> [(Name, [String])] -> Maybe Int -> Maybe Name -> [Int] -> [Maybe Int] -> [(Name, Maybe Accessibility)] -> Accessibility -> Bool -> [IBCWrite] -> Maybe String -> IState

-- | All the currently defined names and their terms
tt_ctxt :: IState -> Context

-- | A list of universe constraints and their corresponding source
--   locations
idris_constraints :: IState -> [(UConstraint, FC)]

-- | Currently defined infix operators
idris_infixes :: IState -> [FixDecl]
idris_implicits :: IState -> Ctxt [PArg]
idris_statics :: IState -> Ctxt [Bool]
idris_classes :: IState -> Ctxt ClassInfo
idris_dsls :: IState -> Ctxt DSL
idris_optimisation :: IState -> Ctxt OptInfo
idris_datatypes :: IState -> Ctxt TypeInfo
idris_patdefs :: IState -> Ctxt [([Name], Term, Term)]
idris_flags :: IState -> Ctxt [FnOpt]
idris_callgraph :: IState -> Ctxt CGInfo
idris_calledgraph :: IState -> Ctxt [Name]
idris_docstrings :: IState -> Ctxt String
idris_totcheck :: IState -> [(FC, Name)]
idris_log :: IState -> String
idris_options :: IState -> IOption
idris_name :: IState -> Int

-- | The currently defined but not proven metavariables
idris_metavars :: IState -> [Name]
idris_coercions :: IState -> [Name]
syntax_rules :: IState -> [Syntax]
syntax_keywords :: IState -> [String]

-- | The imported modules
imported :: IState -> [FilePath]
idris_scprims :: IState -> [(Name, (Int, PrimFn))]
idris_objs :: IState -> [FilePath]
idris_libs :: IState -> [String]
idris_hdrs :: IState -> [String]
proof_list :: IState -> [(Name, [String])]
errLine :: IState -> Maybe Int
lastParse :: IState -> Maybe Name
indent_stack :: IState -> [Int]
brace_stack :: IState -> [Maybe Int]
hide_list :: IState -> [(Name, Maybe Accessibility)]
default_access :: IState -> Accessibility
default_total :: IState -> Bool
ibc_write :: IState -> [IBCWrite]
compiled_so :: IState -> Maybe String
data SizeChange
Smaller :: SizeChange
Same :: SizeChange
Bigger :: SizeChange
Unknown :: SizeChange
type SCGEntry = (Name, [Maybe (Int, SizeChange)])
data CGInfo
CGInfo :: [Name] -> [(Name, [[Name]])] -> [SCGEntry] -> [Name] -> [Int] -> CGInfo
argsdef :: CGInfo -> [Name]
calls :: CGInfo -> [(Name, [[Name]])]
scg :: CGInfo -> [SCGEntry]
argsused :: CGInfo -> [Name]
unusedpos :: CGInfo -> [Int]
primDefs :: [Name]
data IBCWrite
IBCFix :: FixDecl -> IBCWrite
IBCImp :: Name -> IBCWrite
IBCStatic :: Name -> IBCWrite
IBCClass :: Name -> IBCWrite
IBCInstance :: Bool -> Name -> Name -> IBCWrite
IBCDSL :: Name -> IBCWrite
IBCData :: Name -> IBCWrite
IBCOpt :: Name -> IBCWrite
IBCSyntax :: Syntax -> IBCWrite
IBCKeyword :: String -> IBCWrite
IBCImport :: FilePath -> IBCWrite
IBCObj :: FilePath -> IBCWrite
IBCLib :: String -> IBCWrite
IBCHeader :: String -> IBCWrite
IBCAccess :: Name -> Accessibility -> IBCWrite
IBCTotal :: Name -> Totality -> IBCWrite
IBCFlags :: Name -> [FnOpt] -> IBCWrite
IBCCG :: Name -> IBCWrite
IBCDoc :: Name -> IBCWrite
IBCCoercion :: Name -> IBCWrite
IBCDef :: Name -> IBCWrite
idrisInit :: IState

-- | The monad for the main REPL - reading and processing files and
--   updating global state (hence the IO inner monad).
type Idris = StateT IState IO
data Target
ViaC :: Target
ViaJava :: Target
ViaNode :: Target
ViaJavaScript :: Target
Bytecode :: Target

-- | REPL commands
data Command
Quit :: Command
Help :: Command
Eval :: PTerm -> Command
Check :: PTerm -> Command
DocStr :: Name -> Command
TotCheck :: Name -> Command
Reload :: Command
Load :: FilePath -> Command
ModImport :: String -> Command
Edit :: Command
Compile :: Target -> String -> Command
Execute :: Command
ExecVal :: PTerm -> Command
NewCompile :: String -> Command
Metavars :: Command
Prove :: Name -> Command
AddProof :: (Maybe Name) -> Command
RmProof :: Name -> Command
ShowProof :: Name -> Command
Proofs :: Command
Universes :: Command
TTShell :: Command
LogLvl :: Int -> Command
Spec :: PTerm -> Command
HNF :: PTerm -> Command
Defn :: Name -> Command
Info :: Name -> Command
Missing :: Name -> Command
Pattelab :: PTerm -> Command
DebugInfo :: Name -> Command
Search :: PTerm -> Command
SetOpt :: Opt -> Command
UnsetOpt :: Opt -> Command
NOP :: Command
data Opt
Filename :: String -> Opt
Ver :: Opt
Usage :: Opt
ShowLibs :: Opt
ShowLibdir :: Opt
ShowIncs :: Opt
NoPrelude :: Opt
NoREPL :: Opt
OLogging :: Int -> Opt
Output :: String -> Opt
NewOutput :: String -> Opt
TypeCase :: Opt
TypeInType :: Opt
DefaultTotal :: Opt
DefaultPartial :: Opt
WarnPartial :: Opt
NoCoverage :: Opt
ErrContext :: Opt
ShowImpl :: Opt
Verbose :: Opt
IBCSubDir :: String -> Opt
ImportDir :: String -> Opt
PkgBuild :: String -> Opt
PkgInstall :: String -> Opt
PkgClean :: String -> Opt
WarnOnly :: Opt
Pkg :: String -> Opt
BCAsm :: String -> Opt
DumpDefun :: String -> Opt
DumpCases :: String -> Opt
FOVM :: String -> Opt
UseTarget :: Target -> Opt
OutputTy :: OutputType -> Opt
data Fixity
Infixl :: Int -> Fixity
prec :: Fixity -> Int
Infixr :: Int -> Fixity
prec :: Fixity -> Int
InfixN :: Int -> Fixity
prec :: Fixity -> Int
PrefixN :: Int -> Fixity
prec :: Fixity -> Int
data FixDecl
Fix :: Fixity -> String -> FixDecl
data Static
Static :: Static
Dynamic :: Static
data Plicity
Imp :: Bool -> Static -> String -> Plicity
plazy :: Plicity -> Bool
pstatic :: Plicity -> Static
pdocstr :: Plicity -> String
Exp :: Bool -> Static -> String -> Plicity
plazy :: Plicity -> Bool
pstatic :: Plicity -> Static
pdocstr :: Plicity -> String
Constraint :: Bool -> Static -> String -> Plicity
plazy :: Plicity -> Bool
pstatic :: Plicity -> Static
pdocstr :: Plicity -> String
TacImp :: Bool -> Static -> PTerm -> String -> Plicity
plazy :: Plicity -> Bool
pstatic :: Plicity -> Static
pscript :: Plicity -> PTerm
pdocstr :: Plicity -> String
impl :: Plicity
expl :: Plicity
constraint :: Plicity
tacimpl :: PTerm -> Plicity
data FnOpt
Inlinable :: FnOpt
TotalFn :: FnOpt
PartialFn :: FnOpt
Coinductive :: FnOpt
AssertTotal :: FnOpt
TCGen :: FnOpt
Implicit :: FnOpt
CExport :: String -> FnOpt
Specialise :: [Name] -> FnOpt
type FnOpts = [FnOpt]
inlinable :: FnOpts -> Bool

-- | Top-level declarations such as compiler directives, definitions,
--   datatypes and typeclasses.
data PDecl' t

-- | Fixity declaration
PFix :: FC -> Fixity -> [String] -> PDecl' t

-- | Type declaration
PTy :: String -> SyntaxInfo -> FC -> FnOpts -> Name -> t -> PDecl' t

-- | Postulate
PPostulate :: String -> SyntaxInfo -> FC -> FnOpts -> Name -> t -> PDecl' t

-- | Pattern clause
PClauses :: FC -> FnOpts -> Name -> [PClause' t] -> PDecl' t

-- | Top level constant
PCAF :: FC -> Name -> t -> PDecl' t

-- | Data declaration. The Bool argument is True for codata.
PData :: String -> SyntaxInfo -> FC -> Bool -> (PData' t) -> PDecl' t

-- | Params block
PParams :: FC -> [(Name, t)] -> [PDecl' t] -> PDecl' t

-- | New namespace
PNamespace :: String -> [PDecl' t] -> PDecl' t

-- | Record declaration
PRecord :: String -> SyntaxInfo -> FC -> Name -> t -> String -> Name -> t -> PDecl' t

-- | Type class: arguments are documentation, syntax info, source location,
--   constraints, class name, parameters, method declarations
PClass :: String -> SyntaxInfo -> FC -> [t] -> Name -> [(Name, t)] -> [PDecl' t] -> PDecl' t

-- | Instance declaration: arguments are syntax info, source location,
--   constraints, class name, parameters, full instance type, optional
--   explicit name, and definitions
PInstance :: SyntaxInfo -> FC -> [t] -> Name -> [t] -> t -> (Maybe Name) -> [PDecl' t] -> PDecl' t

-- | DSL declaration
PDSL :: Name -> (DSL' t) -> PDecl' t

-- | Syntax definition
PSyntax :: FC -> Syntax -> PDecl' t

-- | Mutual block
PMutual :: FC -> [PDecl' t] -> PDecl' t

-- | Compiler directive. The parser inserts the corresponding action in the
--   Idris monad.
PDirective :: (Idris ()) -> PDecl' t
data PClause' t
PClause :: FC -> Name -> t -> [t] -> t -> [PDecl' t] -> PClause' t
PWith :: FC -> Name -> t -> [t] -> t -> [PDecl' t] -> PClause' t
PClauseR :: FC -> [t] -> t -> [PDecl' t] -> PClause' t
PWithR :: FC -> [t] -> t -> [PDecl' t] -> PClause' t

-- | Data declaration
data PData' t

-- | Data declaration
PDatadecl :: Name -> t -> [(String, Name, t, FC)] -> PData' t

-- | The name of the datatype
d_name :: PData' t -> Name

-- | Type constructor
d_tcon :: PData' t -> t

-- | Constructors
d_cons :: PData' t -> [(String, Name, t, FC)]

-- | <a>Placeholder</a> for data whose constructors are defined later
PLaterdecl :: Name -> t -> PData' t

-- | The name of the datatype
d_name :: PData' t -> Name

-- | Type constructor
d_tcon :: PData' t -> t
type PDecl = PDecl' PTerm
type PData = PData' PTerm
type PClause = PClause' PTerm
declared :: PDecl -> [Name]
tldeclared :: PDecl -> [Name]
defined :: PDecl -> [Name]
updateN :: [(Name, Name)] -> Name -> Name
updateNs :: [(Name, Name)] -> PTerm -> PTerm

-- | High level language terms
data PTerm
PQuote :: Raw -> PTerm
PRef :: FC -> Name -> PTerm

-- | A name to be defined later
PInferRef :: FC -> Name -> PTerm
PPatvar :: FC -> Name -> PTerm
PLam :: Name -> PTerm -> PTerm -> PTerm
PPi :: Plicity -> Name -> PTerm -> PTerm -> PTerm
PLet :: Name -> PTerm -> PTerm -> PTerm -> PTerm

-- | Term with explicit type
PTyped :: PTerm -> PTerm -> PTerm
PApp :: FC -> PTerm -> [PArg] -> PTerm
PCase :: FC -> PTerm -> [(PTerm, PTerm)] -> PTerm
PTrue :: FC -> PTerm
PFalse :: FC -> PTerm
PRefl :: FC -> PTerm -> PTerm
PResolveTC :: FC -> PTerm
PEq :: FC -> PTerm -> PTerm -> PTerm
PPair :: FC -> PTerm -> PTerm -> PTerm
PDPair :: FC -> PTerm -> PTerm -> PTerm -> PTerm
PAlternative :: Bool -> [PTerm] -> PTerm

-- | Irrelevant or hidden pattern
PHidden :: PTerm -> PTerm
PType :: PTerm
PConstant :: Const -> PTerm
Placeholder :: PTerm
PDoBlock :: [PDo] -> PTerm
PIdiom :: FC -> PTerm -> PTerm
PReturn :: FC -> PTerm
PMetavar :: Name -> PTerm

-- | Proof script
PProof :: [PTactic] -> PTerm

-- | As PProof, but no auto solving
PTactics :: [PTactic] -> PTerm

-- | Error to report on elaboration
PElabError :: Err -> PTerm

-- | Special case for declaring when an LHS can't typecheck
PImpossible :: PTerm

-- | To mark a coerced argument, so as not to coerce twice
PCoerced :: PTerm -> PTerm
mapPT :: (PTerm -> PTerm) -> PTerm -> PTerm
data PTactic' t
Intro :: [Name] -> PTactic' t
Intros :: PTactic' t
Focus :: Name -> PTactic' t
Refine :: Name -> [Bool] -> PTactic' t
Rewrite :: t -> PTactic' t
LetTac :: Name -> t -> PTactic' t
LetTacTy :: Name -> t -> t -> PTactic' t
Exact :: t -> PTactic' t
Compute :: PTactic' t
Trivial :: PTactic' t
Solve :: PTactic' t
Attack :: PTactic' t
ProofState :: PTactic' t
ProofTerm :: PTactic' t
Undo :: PTactic' t
Try :: (PTactic' t) -> (PTactic' t) -> PTactic' t
TSeq :: (PTactic' t) -> (PTactic' t) -> PTactic' t
ReflectTac :: t -> PTactic' t
GoalType :: String -> (PTactic' t) -> PTactic' t
Qed :: PTactic' t
Abandon :: PTactic' t
type PTactic = PTactic' PTerm
data PDo' t
DoExp :: FC -> t -> PDo' t
DoBind :: FC -> Name -> t -> PDo' t
DoBindP :: FC -> t -> t -> PDo' t
DoLet :: FC -> Name -> t -> t -> PDo' t
DoLetP :: FC -> t -> t -> PDo' t
type PDo = PDo' PTerm
data PArg' t
PImp :: Int -> Bool -> Name -> t -> String -> PArg' t
priority :: PArg' t -> Int
lazyarg :: PArg' t -> Bool
pname :: PArg' t -> Name
getTm :: PArg' t -> t
pargdoc :: PArg' t -> String
PExp :: Int -> Bool -> t -> String -> PArg' t
priority :: PArg' t -> Int
lazyarg :: PArg' t -> Bool
getTm :: PArg' t -> t
pargdoc :: PArg' t -> String
PConstraint :: Int -> Bool -> t -> String -> PArg' t
priority :: PArg' t -> Int
lazyarg :: PArg' t -> Bool
getTm :: PArg' t -> t
pargdoc :: PArg' t -> String
PTacImplicit :: Int -> Bool -> Name -> t -> t -> String -> PArg' t
priority :: PArg' t -> Int
lazyarg :: PArg' t -> Bool
pname :: PArg' t -> Name
getScript :: PArg' t -> t
getTm :: PArg' t -> t
pargdoc :: PArg' t -> String
pimp :: Name -> t -> PArg' t
pexp :: t -> PArg' t
pconst :: t -> PArg' t
ptacimp :: Name -> t -> t -> PArg' t
type PArg = PArg' PTerm
data ClassInfo
CI :: Name -> [(Name, (FnOpts, PTerm))] -> [(Name, (Name, PDecl))] -> [Name] -> [Name] -> ClassInfo
instanceName :: ClassInfo -> Name
class_methods :: ClassInfo -> [(Name, (FnOpts, PTerm))]
class_defaults :: ClassInfo -> [(Name, (Name, PDecl))]
class_params :: ClassInfo -> [Name]
class_instances :: ClassInfo -> [Name]
data OptInfo
Optimise :: Bool -> [Int] -> [Int] -> OptInfo
collapsible :: OptInfo -> Bool
forceable :: OptInfo -> [Int]
recursive :: OptInfo -> [Int]
data TypeInfo
TI :: [Name] -> Bool -> [Int] -> TypeInfo
con_names :: TypeInfo -> [Name]
codata :: TypeInfo -> Bool
param_pos :: TypeInfo -> [Int]
data DSL' t
DSL :: t -> t -> t -> t -> Maybe t -> Maybe t -> Maybe t -> Maybe t -> Maybe t -> DSL' t
dsl_bind :: DSL' t -> t
dsl_return :: DSL' t -> t
dsl_apply :: DSL' t -> t
dsl_pure :: DSL' t -> t
dsl_var :: DSL' t -> Maybe t
index_first :: DSL' t -> Maybe t
index_next :: DSL' t -> Maybe t
dsl_lambda :: DSL' t -> Maybe t
dsl_let :: DSL' t -> Maybe t
type DSL = DSL' PTerm
data SynContext
PatternSyntax :: SynContext
TermSyntax :: SynContext
AnySyntax :: SynContext
data Syntax
Rule :: [SSymbol] -> PTerm -> SynContext -> Syntax
data SSymbol
Keyword :: Name -> SSymbol
Symbol :: String -> SSymbol
Binding :: Name -> SSymbol
Expr :: Name -> SSymbol
SimpleExpr :: Name -> SSymbol
initDSL :: DSL' PTerm
data SyntaxInfo
Syn :: [(Name, PTerm)] -> [(Name, PTerm)] -> [String] -> [Name] -> (Name -> Name) -> Bool -> Bool -> DSL -> SyntaxInfo
using :: SyntaxInfo -> [(Name, PTerm)]
syn_params :: SyntaxInfo -> [(Name, PTerm)]
syn_namespace :: SyntaxInfo -> [String]
no_imp :: SyntaxInfo -> [Name]
decoration :: SyntaxInfo -> Name -> Name
inPattern :: SyntaxInfo -> Bool
implicitAllowed :: SyntaxInfo -> Bool
dsl_info :: SyntaxInfo -> DSL
defaultSyntax :: SyntaxInfo
expandNS :: SyntaxInfo -> Name -> Name
showDeclImp :: Bool -> PDecl' PTerm -> [Char]
showCImp :: Bool -> PClause -> String
showDImp :: Bool -> PData -> String
getImps :: [PArg] -> [(Name, PTerm)]
getExps :: [PArg] -> [PTerm]
getConsts :: [PArg] -> [PTerm]
getAll :: [PArg] -> [PTerm]
prettyImp :: Bool -> PTerm -> Doc
showImp :: Bool -> PTerm -> String
getPArity :: PTerm -> Int
allNamesIn :: PTerm -> [Name]
namesIn :: [(Name, PTerm)] -> IState -> PTerm -> [Name]
usedNamesIn :: [Name] -> IState -> PTerm -> [Name]
instance Show SizeChange
instance Eq SizeChange
instance Show CGInfo
instance Show Target
instance Eq Target
instance Show Opt
instance Eq Opt
instance Show IOption
instance Eq IOption
instance Eq Fixity
instance Eq FixDecl
instance Show Static
instance Eq Static
instance Show FnOpt
instance Eq FnOpt
instance Functor PData'
instance Show t => Show (PTactic' t)
instance Eq t => Eq (PTactic' t)
instance Functor PTactic'
instance Eq t => Eq (PDo' t)
instance Functor PDo'
instance Show t => Show (PArg' t)
instance Eq t => Eq (PArg' t)
instance Functor PArg'
instance Eq PTerm
instance Show Plicity
instance Eq Plicity
instance Show OptInfo
instance Show TypeInfo
instance Show t => Show (DSL' t)
instance Functor DSL'
instance Show SynContext
instance Show SSymbol
instance Show Syntax
instance Show IBCWrite
instance Show SyntaxInfo
instance Functor PDecl'
instance Functor PClause'
instance Show ClassInfo
instance Sized PTerm
instance Show PData
instance Show PClause
instance Show PDecl
instance Pretty PTerm
instance Show PTerm
instance Sized a => Sized (PArg' a)
instance Sized a => Sized (PDo' a)
instance Sized a => Sized (PTactic' a)
instance Ord FixDecl
instance Show FixDecl
instance Show Fixity

module Idris.AbsSyntax
getContext :: Idris Context
getObjectFiles :: Idris [FilePath]
addObjectFile :: FilePath -> Idris ()
getLibs :: Idris [String]
addLib :: String -> Idris ()
addHdr :: String -> Idris ()
totcheck :: (FC, Name) -> Idris ()
setFlags :: Name -> [FnOpt] -> Idris ()
setAccessibility :: Name -> Accessibility -> Idris ()
setTotality :: Name -> Totality -> Idris ()
getTotality :: Name -> Idris Totality
getCoercionsTo :: IState -> Type -> [Name]
addToCG :: Name -> CGInfo -> Idris ()
addCoercion :: Name -> Idris ()
addDocStr :: Name -> String -> Idris ()
addToCalledG :: Name -> [Name] -> Idris ()
addInstance :: Bool -> Name -> Name -> Idris ()
addClass :: Name -> ClassInfo -> Idris ()
addIBC :: IBCWrite -> Idris ()
clearIBC :: Idris ()
getHdrs :: Idris [String]
setErrLine :: Int -> Idris ()
clearErr :: Idris ()
getSO :: Idris (Maybe String)
setSO :: Maybe String -> Idris ()
getIState :: Idris IState
putIState :: IState -> Idris ()
getName :: Idris Int
checkUndefined :: FC -> Name -> Idris ()
isUndefined :: FC -> Name -> Idris Bool
setContext :: Context -> Idris ()
updateContext :: (Context -> Context) -> Idris ()
addConstraints :: FC -> (Int, [UConstraint]) -> Idris ()
addDeferred :: [(Name, Type)] -> Idris ()
solveDeferred :: Name -> Idris ()
iputStrLn :: String -> Idris ()
iWarn :: FC -> String -> Idris ()
setLogLevel :: Int -> Idris ()
setCmdLine :: [Opt] -> Idris ()
getDumpDefun :: Idris (Maybe FilePath)
getDumpCases :: Idris (Maybe FilePath)
logLevel :: Idris Int
setErrContext :: Bool -> Idris ()
errContext :: Idris Bool
useREPL :: Idris Bool
setREPL :: Bool -> Idris ()
setTarget :: Target -> Idris ()
target :: Idris Target
setOutputTy :: OutputType -> Idris ()
outputTy :: Idris OutputType
verbose :: Idris Bool
setVerbose :: Bool -> Idris ()
typeInType :: Idris Bool
setTypeInType :: Bool -> Idris ()
coverage :: Idris Bool
setCoverage :: Bool -> Idris ()
setIBCSubDir :: FilePath -> Idris ()
valIBCSubDir :: IState -> Idris FilePath
addImportDir :: FilePath -> Idris ()
setImportDirs :: [FilePath] -> Idris ()
allImportDirs :: IState -> Idris [FilePath]
impShow :: Idris Bool
setImpShow :: Bool -> Idris ()
logLvl :: Int -> String -> Idris ()
cmdOptType :: Opt -> Idris Bool
iLOG :: String -> Idris ()
noErrors :: Idris Bool
setTypeCase :: Bool -> Idris ()
bi :: FC
inferTy :: Name
inferCon :: Name
inferDecl :: PData' PTerm
infTerm :: PTerm -> PTerm
infP :: TT Name
getInferTerm :: Term -> Term
getInferType :: Term -> Term
primNames :: [Name]
unitTy :: Name
unitCon :: Name
unitDecl :: PData' PTerm
falseTy :: Name
falseDecl :: PData' PTerm
pairTy :: Name
pairCon :: Name
pairDecl :: PData' PTerm
eqTy :: Name
eqCon :: Name
eqDecl :: PData' PTerm
sigmaTy :: Name
existsCon :: Name
piBind :: [(Name, PTerm)] -> PTerm -> PTerm
piBindp :: Plicity -> [(Name, PTerm)] -> PTerm -> PTerm
expandParams :: (Name -> Name) -> [(Name, PTerm)] -> [Name] -> [Name] -> PTerm -> PTerm
expandParamsD :: Bool -> IState -> (Name -> Name) -> [(Name, PTerm)] -> [Name] -> PDecl -> PDecl
mapsnd :: (t -> t2) -> (t1, t) -> (t1, t2)
getPriority :: IState -> PTerm -> Int
addStatics :: Name -> Term -> PTerm -> Idris ()
implicit :: SyntaxInfo -> Name -> PTerm -> Idris PTerm
implicit' :: SyntaxInfo -> [Name] -> Name -> PTerm -> Idris PTerm
implicitise :: SyntaxInfo -> [Name] -> IState -> PTerm -> (PTerm, [PArg])
addImplPat :: IState -> PTerm -> PTerm
addImplBound :: IState -> [Name] -> PTerm -> PTerm
addImplBoundInf :: IState -> [Name] -> [Name] -> PTerm -> PTerm
addImpl :: IState -> PTerm -> PTerm
addImpl' :: Bool -> [Name] -> [Name] -> IState -> PTerm -> PTerm
aiFn :: Bool -> Bool -> IState -> FC -> Name -> [PArg] -> Either Err PTerm
mkPApp :: FC -> Int -> PTerm -> [PArg] -> PTerm
findStatics :: IState -> PTerm -> (PTerm, [Bool])
dumpDecls :: [PDecl] -> String
dumpDecl :: PDecl' PTerm -> [Char]
data EitherErr a b
LeftErr :: a -> EitherErr a b
RightOK :: b -> EitherErr a b
toEither :: EitherErr a b -> Either a b
matchClause :: IState -> PTerm -> PTerm -> Either (PTerm, PTerm) [(Name, PTerm)]
matchClause' :: Bool -> IState -> PTerm -> PTerm -> Either (PTerm, PTerm) [(Name, PTerm)]
substMatches :: [(Name, PTerm)] -> PTerm -> PTerm
substMatchesShadow :: [(Name, PTerm)] -> [Name] -> PTerm -> PTerm
substMatch :: Name -> PTerm -> PTerm -> PTerm
substMatchShadow :: Name -> [Name] -> PTerm -> PTerm -> PTerm
shadow :: Name -> Name -> PTerm -> PTerm
instance Monad (EitherErr a)

module Idris.Imports
data IFileType
IDR :: FilePath -> IFileType
LIDR :: FilePath -> IFileType
IBC :: FilePath -> IFileType -> IFileType
srcPath :: FilePath -> FilePath
lsrcPath :: FilePath -> FilePath
ibcPath :: FilePath -> Bool -> FilePath -> FilePath
ibcPathWithFallback :: FilePath -> FilePath -> IO FilePath
ibcPathNoFallback :: FilePath -> FilePath -> FilePath
findImport :: [FilePath] -> FilePath -> FilePath -> IO IFileType
findInPath :: [FilePath] -> FilePath -> IO FilePath
instance Eq IFileType

module Idris.Delaborate
bugaddr :: [Char]
delab :: IState -> Term -> PTerm
delab' :: IState -> Term -> Bool -> PTerm
pshow :: IState -> Err -> String
showSc :: IState -> [(Name, Term)] -> [Char]
showbasic :: Name -> String

module Idris.Error
iucheck :: Idris ()
report :: IOError -> String
idrisCatch :: Idris a -> (SomeException -> Idris a) -> Idris a
data IdrisErr
IErr :: String -> IdrisErr
ifail :: String -> Idris ()
ierror :: Err -> Idris ()
tclift :: TC a -> Idris a
tctry :: TC a -> TC a -> Idris a
getErrLine :: (Num a, Read a) => [Char] -> a
instance Typeable IdrisErr
instance Exception IdrisErr
instance Show IdrisErr

module Idris.Coverage
genMissing :: Name -> [Name] -> SC -> Idris [PTerm]
mkPatTm :: PTerm -> Idris Term
mkPTerm :: Name -> [TT Name] -> Idris PTerm
gm :: Name -> [TT Name] -> SC -> Idris ([PTerm], [PTerm])
gmAlt :: Name -> [TT Name] -> Name -> CaseAlt' Term -> Idris ([PTerm], [PTerm])
getDefault :: [CaseAlt' t] -> SC' t
dropDefault :: [CaseAlt' t] -> [CaseAlt' t]
expandTree :: SC -> Idris SC
expandAlts :: IState -> [CaseAlt] -> SC -> Idris [CaseAlt]
genClauses :: FC -> Name -> [Term] -> [PClause] -> Idris [PTerm]
fnub :: Eq a => [a] -> [a]
genAll :: IState -> [PTerm] -> [PTerm]
upd :: t -> PArg' t -> PArg' t
checkPositive :: Name -> (Name, Type) -> Idris ()
data LexOrder
LexXX :: LexOrder
LexEQ :: LexOrder
LexLT :: LexOrder
calcProd :: IState -> FC -> Name -> [([Name], Term, Term)] -> Idris Totality
calcTotality :: [Name] -> FC -> Name -> [([Name], Term, Term)] -> Idris Totality
checkTotality :: [Name] -> FC -> Name -> Idris Totality
checkDeclTotality :: (FC, Name) -> Idris Totality
buildSCG :: (FC, Name) -> Idris ()
buildSCG' :: IState -> SC -> [Name] -> [SCGEntry]
checkSizeChange :: Name -> Idris Totality
type MultiPath = [SCGEntry]
mkMultiPaths :: IState -> MultiPath -> [SCGEntry] -> [MultiPath]
checkMP :: IState -> Int -> MultiPath -> Totality
collapseNothing :: [(Maybe t1, t)] -> [(Maybe t1, t)]
noPartial :: [Totality] -> Totality
collapse :: [Totality] -> Totality
collapse' :: Totality -> [Totality] -> Totality
instance Show LexOrder
instance Eq LexOrder
instance Ord LexOrder

module Idris.Compiler
compileEpic :: FilePath -> Term -> Idris ()

module Idris.IBC
ibcVersion :: Word8
data IBCFile
IBCFile :: Word8 -> FilePath -> [FilePath] -> [(Name, [PArg])] -> [FixDecl] -> [(Name, [Bool])] -> [(Name, ClassInfo)] -> [(Bool, Name, Name)] -> [(Name, DSL)] -> [(Name, TypeInfo)] -> [(Name, OptInfo)] -> [Syntax] -> [String] -> [FilePath] -> [String] -> [String] -> [(Name, Accessibility)] -> [(Name, Totality)] -> [(Name, [FnOpt])] -> [(Name, CGInfo)] -> [(Name, Def)] -> [(Name, String)] -> [Name] -> IBCFile
ver :: IBCFile -> Word8
sourcefile :: IBCFile -> FilePath
ibc_imports :: IBCFile -> [FilePath]
ibc_implicits :: IBCFile -> [(Name, [PArg])]
ibc_fixes :: IBCFile -> [FixDecl]
ibc_statics :: IBCFile -> [(Name, [Bool])]
ibc_classes :: IBCFile -> [(Name, ClassInfo)]
ibc_instances :: IBCFile -> [(Bool, Name, Name)]
ibc_dsls :: IBCFile -> [(Name, DSL)]
ibc_datatypes :: IBCFile -> [(Name, TypeInfo)]
ibc_optimise :: IBCFile -> [(Name, OptInfo)]
ibc_syntax :: IBCFile -> [Syntax]
ibc_keywords :: IBCFile -> [String]
ibc_objs :: IBCFile -> [FilePath]
ibc_libs :: IBCFile -> [String]
ibc_hdrs :: IBCFile -> [String]
ibc_access :: IBCFile -> [(Name, Accessibility)]
ibc_total :: IBCFile -> [(Name, Totality)]
ibc_flags :: IBCFile -> [(Name, [FnOpt])]
ibc_cg :: IBCFile -> [(Name, CGInfo)]
ibc_defs :: IBCFile -> [(Name, Def)]
ibc_docstrings :: IBCFile -> [(Name, String)]
ibc_coercions :: IBCFile -> [Name]
initIBC :: IBCFile
loadIBC :: FilePath -> Idris ()
writeIBC :: FilePath -> FilePath -> Idris ()
mkIBC :: [IBCWrite] -> IBCFile -> Idris IBCFile
ibc :: Monad m => IState -> IBCWrite -> IBCFile -> m IBCFile
process :: IBCFile -> FilePath -> Idris ()
timestampOlder :: FilePath -> FilePath -> IO ()
pImports :: [FilePath] -> Idris ()
pImps :: [(Name, [PArg])] -> Idris ()
pFixes :: [FixDecl] -> Idris ()
pStatics :: [(Name, [Bool])] -> Idris ()
pClasses :: [(Name, ClassInfo)] -> Idris ()
pInstances :: [(Bool, Name, Name)] -> Idris ()
pDSLs :: [(Name, DSL)] -> Idris ()
pDatatypes :: [(Name, TypeInfo)] -> Idris ()
pOptimise :: [(Name, OptInfo)] -> Idris ()
pSyntax :: [Syntax] -> Idris ()
pKeywords :: [String] -> Idris ()
pObjs :: [FilePath] -> Idris ()
pLibs :: [String] -> Idris ()
pHdrs :: [String] -> Idris ()
pDefs :: [(Name, Def)] -> Idris ()
pDocs :: [(Name, String)] -> Idris ()
pAccess :: [(Name, Accessibility)] -> Idris ()
pFlags :: [(Name, [FnOpt])] -> Idris ()
pTotal :: [(Name, Totality)] -> Idris ()
pCG :: [(Name, CGInfo)] -> Idris ()
pCoercions :: [Name] -> Idris ()
instance Binary SSymbol
instance Binary t => Binary (DSL' t)
instance Binary Syntax
instance Binary SynContext
instance Binary TypeInfo
instance Binary OptInfo
instance Binary ClassInfo
instance Binary t => Binary (PArg' t)
instance Binary t => Binary (PDo' t)
instance Binary t => Binary (PTactic' t)
instance Binary PTerm
instance Binary t => Binary (PData' t)
instance Binary t => Binary (PClause' t)
instance Binary SyntaxInfo
instance Binary t => Binary (PDecl' t)
instance Binary Plicity
instance Binary Static
instance Binary FixDecl
instance Binary Fixity
instance Binary FnOpt
instance Binary IBCFile
instance Binary Totality
instance Binary PReason
instance Binary Accessibility
instance Binary Def
instance Binary CaseAlt
instance Binary SC
instance Binary n => Binary (TT n)
instance Binary NameType
instance Binary b => Binary (Binder b)
instance Binary Raw
instance Binary Const
instance Binary Name
instance Binary FC
instance Binary CGInfo
instance Binary SizeChange

module Idris.UnusedArgs
findUnusedArgs :: [Name] -> Idris ()
traceUnused :: Name -> Idris ()
used :: [(Name, Int)] -> Name -> Int -> Idris Bool
getFargpos :: [(Name, [[Name]])] -> (Name, Int) -> [(Name, Int, (Name, Int))]

module Idris.DataOpts
forceArgs :: Name -> Type -> Idris ()
collapseCons :: Name -> [(Name, Type)] -> Idris ()
class Optimisable term
applyOpts :: Optimisable term => term -> Idris term
stripCollapsed :: Optimisable term => term -> Idris term
applyDataOpt :: OptInfo -> Name -> [Raw] -> Raw
applyDataOptRT :: OptInfo -> Name -> Int -> Int -> [Term] -> Term
instance Optimisable (TT Name)
instance Optimisable t => Optimisable (Binder t)
instance Optimisable Raw
instance Optimisable a => Optimisable (Either a (a, a))
instance Optimisable a => Optimisable [a]
instance (Optimisable a, Optimisable b) => Optimisable (vs, a, b)
instance (Optimisable a, Optimisable b) => Optimisable (a, b)

module Idris.Transforms
data TTOpt
TermTrans :: (TT Name -> TT Name) -> TTOpt
CaseTrans :: (SC -> SC) -> TTOpt
class Transform a
transform :: Transform a => TTOpt -> a -> a
natTrans :: [TTOpt]
zname :: Name
sname :: Name
zero :: TT Name -> TT Name
suc :: TT Name -> TT Name
natcase :: SC -> SC
instance Transform CaseAlt
instance Transform SC
instance Transform a => Transform (Binder a)
instance Transform (TT Name)

module Idris.Docs
data FunDoc
Doc :: Name -> String -> [(Name, PArg)] -> PTerm -> (Maybe Fixity) -> FunDoc
data Doc
FunDoc :: FunDoc -> Doc
DataDoc :: FunDoc -> [FunDoc] -> Doc
ClassDoc :: Name -> String -> [FunDoc] -> Doc
showDoc :: [Char] -> [Char]
getDocs :: Name -> Idris Doc
docData :: Name -> TypeInfo -> Idris Doc
docClass :: Name -> ClassInfo -> Idris Doc
docFun :: Name -> Idris FunDoc
instance Show Doc
instance Show FunDoc


-- | Support for command-line completion at the REPL and in the prover
module Idris.Completion

-- | Complete REPL commands and defined identifiers
replCompletion :: CompletionFunc Idris

-- | Complete tactics and their arguments
proverCompletion :: [String] -> CompletionFunc Idris

module IRTS.Bytecode
data Reg
RVal :: Reg
L :: Int -> Reg
T :: Int -> Reg
Tmp :: Reg
data BC
ASSIGN :: Reg -> Reg -> BC
ASSIGNCONST :: Reg -> Const -> BC
UPDATE :: Reg -> Reg -> BC
MKCON :: Reg -> Int -> [Reg] -> BC
CASE :: Bool -> Reg -> [(Int, [BC])] -> (Maybe [BC]) -> BC
PROJECT :: Reg -> Int -> Int -> BC
PROJECTINTO :: Reg -> Reg -> Int -> BC
CONSTCASE :: Reg -> [(Const, [BC])] -> (Maybe [BC]) -> BC
CALL :: Name -> BC
TAILCALL :: Name -> BC
FOREIGNCALL :: Reg -> FLang -> FType -> String -> [(FType, Reg)] -> BC
SLIDE :: Int -> BC
REBASE :: BC
RESERVE :: Int -> BC
ADDTOP :: Int -> BC
TOPBASE :: Int -> BC
BASETOP :: Int -> BC
STOREOLD :: BC
OP :: Reg -> PrimFn -> [Reg] -> BC
NULL :: Reg -> BC
ERROR :: String -> BC
toBC :: (Name, SDecl) -> (Name, [BC])
clean :: Bool -> [BC]
bc :: Reg -> SExp -> Bool -> [BC]
isConst :: [SAlt] -> Bool
moveReg :: Int -> [LVar] -> [BC]
assign :: Reg -> Reg -> [BC]
conCase :: Bool -> Reg -> Reg -> [SAlt] -> Bool -> [BC]
constCase :: Reg -> Reg -> [SAlt] -> Bool -> [BC]
caseAlt :: Reg -> Reg -> Bool -> SAlt -> Maybe (Int, [BC])
constAlt :: t -> Reg -> Bool -> SAlt -> Maybe (Const, [BC])
defaultAlt :: Reg -> [SAlt] -> Bool -> Maybe [BC]
instance Show Reg
instance Eq Reg
instance Show BC

module IRTS.CodegenC
codegenC :: [(Name, SDecl)] -> String -> OutputType -> [FilePath] -> String -> String -> DbgLevel -> IO ()

module IRTS.CodegenJavaScript
codegenJavaScript :: JSTarget -> [(Name, SDecl)] -> FilePath -> OutputType -> IO ()
data JSTarget
Node :: JSTarget
JavaScript :: JSTarget

module IRTS.Inliner
inline :: DDefs -> DDefs
inl :: DDefs -> (Name, DDecl) -> (Name, DDecl)
evalD :: t -> a -> Maybe a

module IRTS.DumpBC
interMap :: [a] -> [b] -> (a -> [b]) -> [b]
indent :: Int -> String
serializeReg :: Reg -> String
serializeCase :: Show a => Int -> (a, [BC]) -> String
serializeDefault :: Int -> [BC] -> String
serializeBC :: Int -> BC -> String
serialize :: [(Name, [BC])] -> String
dumpBC :: [(Name, SDecl)] -> String -> IO ()

module IRTS.BCImp
data Reg
RVal :: Reg
L :: Int -> Reg
data BC
NOP :: BC
toBC :: (Name, SDecl) -> (Name, [BC])
bc :: Reg -> SExp -> [BC]

module IRTS.CodegenJava
codegenJava :: [(Name, SDecl)] -> String -> OutputType -> IO ()

module IRTS.Compiler
compile :: Target -> FilePath -> Term -> Idris ()
irMain :: TT Name -> Idris LDecl
allNames :: [Name] -> Name -> Idris [Name]
mkDecls :: Term -> [Name] -> Idris [(Name, LDecl)]
showCaseTrees :: [(Name, LDecl)] -> String
isCon :: Def -> Bool
class ToIR a
ir :: ToIR a => a -> Idris LExp
build :: (Name, Def) -> Idris (Name, LDecl)
getPrim :: IState -> Name -> [LExp] -> Maybe LExp
declArgs :: [Name] -> Bool -> Name -> LExp -> LDecl
mkLDecl :: Name -> Def -> StateT IState IO LDecl
getFTypes :: TT Name -> [FType]
mkIty' :: TT Name -> FType
mkIty :: [Char] -> FType
zname :: Name
sname :: Name
instance ToIR SC
instance ToIR ([Name], SC)
instance ToIR (TT Name)

module Core.CoreParser
parseTerm :: [Char] -> Either ParseError Raw
parseFile :: [Char] -> Either ParseError RProgram
parseDef :: [Char] -> Either ParseError (Name, RDef)
pTerm :: CParser a Raw
iName :: [String] -> CParser a Name
idrisLexer :: TokenParser a
maybeWithNS :: CParser a String -> Bool -> [String] -> CParser a Name
pDocComment :: Char -> CParser a String

module Core.ShellParser
parseCommand :: String -> Either ParseError Command
parseTactic :: String -> Either ParseError Command

module Core.ProofShell
data ShellState
ShellState :: Context -> Maybe ProofState -> [(Name, ProofState)] -> Bool -> ShellState
ctxt :: ShellState -> Context
prf :: ShellState -> Maybe ProofState
deferred :: ShellState -> [(Name, ProofState)]
exitNow :: ShellState -> Bool
initState :: Context -> ShellState
processCommand :: Command -> ShellState -> (ShellState, String)
runShell :: ShellState -> Idris ShellState

module Idris.DSL
desugar :: SyntaxInfo -> IState -> PTerm -> PTerm
expandDo :: DSL -> PTerm -> PTerm
var :: DSL -> Name -> PTerm -> Int -> PTerm
unIdiom :: PTerm -> PTerm -> FC -> PTerm -> PTerm

module Idris.ElabTerm
data ElabInfo
EInfo :: [(Name, PTerm)] -> Ctxt [Name] -> (Name -> Name) -> Maybe [String] -> ElabInfo
params :: ElabInfo -> [(Name, PTerm)]
inblock :: ElabInfo -> Ctxt [Name]
liftname :: ElabInfo -> Name -> Name
namespace :: ElabInfo -> Maybe [String]
toplevel :: ElabInfo
type ElabD a = Elab' [PDecl] a
build :: IState -> ElabInfo -> Bool -> Name -> PTerm -> ElabD (Term, [(Name, Type)], [PDecl])
buildTC :: IState -> ElabInfo -> Bool -> Bool -> Name -> PTerm -> ElabD (Term, [(Name, Type)], [PDecl])
elab :: IState -> ElabInfo -> Bool -> Bool -> Name -> PTerm -> ElabD ()
pruneAlt :: [PTerm] -> [PTerm]
pruneByType :: Term -> Context -> [PTerm] -> [PTerm]
trivial :: IState -> ElabD ()
findInstances :: IState -> Term -> [Name]
resolveTC :: Int -> Name -> IState -> ElabD ()
collectDeferred :: Term -> State [(Name, Type)] Term
runTac :: Bool -> IState -> PTactic -> ElabD ()
solveAll :: Elab' aux ()
mkSpecialised :: IState -> FC -> Name -> [PTerm] -> PTerm -> ElabD PTerm
mkSpecDecl :: IState -> Name -> [(PTerm, Bool)] -> PTerm -> ElabD PTerm

module Idris.ElabDecls
recheckC :: FC -> Env -> TT Name -> StateT IState IO (Term, Type)
checkDef :: FC -> [(t, TT Name)] -> StateT IState IO [(t, Term)]
elabType :: ElabInfo -> SyntaxInfo -> String -> FC -> FnOpts -> Name -> PTerm -> Idris ()
elabPostulate :: ElabInfo -> SyntaxInfo -> String -> FC -> FnOpts -> Name -> PTerm -> Idris ()
elabData :: ElabInfo -> SyntaxInfo -> String -> FC -> Bool -> PData -> Idris ()
elabRecord :: ElabInfo -> SyntaxInfo -> String -> FC -> Name -> PTerm -> String -> Name -> PTerm -> Idris ()
elabCon :: ElabInfo -> SyntaxInfo -> Name -> Bool -> (String, Name, PTerm, FC) -> Idris (Name, Type)
elabClauses :: ElabInfo -> FC -> FnOpts -> Name -> [PClause] -> Idris ()
elabVal :: ElabInfo -> Bool -> PTerm -> Idris (Term, Type)
checkPossible :: ElabInfo -> FC -> Bool -> Name -> PTerm -> Idris Bool
elabClause :: ElabInfo -> Bool -> (Int, PClause) -> Idris (Either Term (Term, Term))
data MArgTy
IA :: MArgTy
EA :: MArgTy
CA :: MArgTy
elabClass :: ElabInfo -> SyntaxInfo -> String -> FC -> [PTerm] -> Name -> [(Name, PTerm)] -> [PDecl] -> Idris ()
elabInstance :: ElabInfo -> SyntaxInfo -> FC -> [PTerm] -> Name -> [PTerm] -> PTerm -> Maybe Name -> [PDecl] -> Idris ()
decorateid :: (Name -> Name) -> PDecl' PTerm -> PDecl' PTerm
pbinds :: TT Name -> StateT (ElabState aux) TC ()
pbty :: TT n -> TT n -> TT n
getPBtys :: TT t -> [(t, TT t)]
psolve :: TT t -> StateT (ElabState aux) TC ()
pvars :: IState -> TT Name -> [(Name, PTerm)]
data ElabWhat
ETypes :: ElabWhat
EDefns :: ElabWhat
EAll :: ElabWhat
elabDecls :: ElabInfo -> [PDecl] -> Idris ()
elabDecl :: ElabWhat -> ElabInfo -> PDecl -> Idris ()
elabDecl' :: ElabWhat -> ElabInfo -> PDecl' PTerm -> StateT IState IO ()
elabCaseBlock :: ElabInfo -> PDecl' PTerm -> StateT IState IO ()
checkInferred :: FC -> PTerm -> PTerm -> Idris ()
inferredDiff :: FC -> PTerm -> PTerm -> Idris Bool
instance Show MArgTy
instance Show ElabWhat
instance Eq ElabWhat


-- | Parse the full Idris language.
module Idris.Parser
type TokenParser a = TokenParser a
type IParser = GenParser Char IState
lexer :: TokenParser IState
whiteSpace :: ParsecT String IState Identity ()
lexeme :: ParsecT String IState Identity a -> ParsecT String IState Identity a
symbol :: String -> ParsecT String IState Identity String
natural :: ParsecT String IState Identity Integer
parens :: ParsecT String IState Identity a -> ParsecT String IState Identity a
semi :: ParsecT String IState Identity String
comma :: ParsecT String IState Identity String
identifier :: ParsecT String IState Identity String
reserved :: String -> ParsecT String IState Identity ()
operator :: ParsecT String IState Identity String
reservedOp :: String -> ParsecT String IState Identity ()
integer :: ParsecT String IState Identity Integer
float :: ParsecT String IState Identity Double
strlit :: ParsecT String IState Identity String
chlit :: ParsecT String IState Identity Char
lchar :: Char -> ParsecT String IState Identity Char
fixErrorMsg :: String -> [String] -> String
loadModule :: FilePath -> Idris String
loadSource :: Bool -> FilePath -> Idris ()
addHides :: [(Name, Maybe Accessibility)] -> Idris ()
parseExpr :: IState -> [Char] -> Either ParseError PTerm
parseTac :: IState -> [Char] -> Either ParseError PTactic
parseImports :: FilePath -> String -> Idris ([String], [String], String, SourcePos)
pHeader :: IParser [String]
pushIndent :: IParser ()
lastIndent :: IParser Int
indent :: IParser Int
popIndent :: IParser ()
openBlock :: IParser ()
closeBlock :: IParser ()
pTerminator :: ParsecT String IState Identity ()
pBarTerminator :: ParsecT String IState Identity ()
pKeepTerminator :: ParsecT String IState Identity ()
notEndApp :: ParsecT [Char] IState Identity ()
notEndBlock :: ParsecT [Char] IState Identity ()

-- | Use Parsec's internal state to construct a source code position
pfc :: IParser FC
pImport :: IParser String

-- | A program is a list of declarations, possibly with associated
--   documentation strings.
parseProg :: SyntaxInfo -> FilePath -> String -> SourcePos -> Idris [PDecl]

-- | Collect <a>PClauses</a> with the same function name
collect :: [PDecl] -> [PDecl]
pFullExpr :: SyntaxInfo -> IParser PTerm

-- | Parse a top-level declaration
pDecl :: SyntaxInfo -> IParser [PDecl]
pFunDecl :: SyntaxInfo -> IParser [PDecl]
pDecl' :: SyntaxInfo -> IParser PDecl
pSyntaxDecl :: SyntaxInfo -> IParser PDecl
pSyntaxRule :: SyntaxInfo -> IParser Syntax
pSynSym :: IParser SSymbol
pFunDecl' :: SyntaxInfo -> IParser PDecl
pPostulate :: SyntaxInfo -> IParser PDecl
pUsing :: SyntaxInfo -> IParser [PDecl]
pParams :: SyntaxInfo -> IParser [PDecl]
pMutual :: SyntaxInfo -> IParser [PDecl]
pNamespace :: SyntaxInfo -> IParser [PDecl]
pFixity :: IParser PDecl
fixity :: IParser (Int -> Fixity)
pClass :: SyntaxInfo -> IParser [PDecl]
pInstance :: SyntaxInfo -> IParser [PDecl]
pExpr :: SyntaxInfo -> ParsecT String IState Identity PTerm
pExpr' :: SyntaxInfo -> IParser PTerm
pExtExpr :: SyntaxInfo -> IParser PTerm
pSimpleExtExpr :: SyntaxInfo -> IParser PTerm
pNoExtExpr :: SyntaxInfo -> ParsecT String IState Identity PTerm
pExtensions :: SyntaxInfo -> [Syntax] -> IParser PTerm
data SynMatch
SynTm :: PTerm -> SynMatch
SynBind :: Name -> SynMatch
pExt :: SyntaxInfo -> Syntax -> IParser PTerm
pName :: ParsecT [Char] IState Identity Name

-- | Parser for an operator in function position, i.e. enclosed by `()',
--   with an optional namespace.
pOpFront :: CParser IState Name
pfName :: ParsecT [Char] IState Identity Name
pTotality :: IParser Bool
pAccessibility' :: IParser Accessibility
pAccessibility :: IParser (Maybe Accessibility)
pFnOpts :: [FnOpt] -> IParser [FnOpt]
addAcc :: Name -> Maybe Accessibility -> IParser ()
pCaseExpr :: SyntaxInfo -> ParsecT String IState Identity PTerm
pProofExpr :: SyntaxInfo -> ParsecT String IState Identity PTerm
pTacticsExpr :: SyntaxInfo -> ParsecT String IState Identity PTerm
pSimpleExpr :: SyntaxInfo -> ParsecT String IState Identity PTerm
bracketed :: SyntaxInfo -> ParsecT String IState Identity PTerm
pCaseOpt :: SyntaxInfo -> IParser (PTerm, PTerm)
modifyConst :: SyntaxInfo -> FC -> PTerm -> PTerm
pList :: SyntaxInfo -> ParsecT String IState Identity PTerm
pPair :: SyntaxInfo -> ParsecT String IState Identity PTerm
pAlt :: SyntaxInfo -> ParsecT String IState Identity PTerm
pHSimpleExpr :: SyntaxInfo -> ParsecT String IState Identity PTerm
pApp :: SyntaxInfo -> ParsecT String IState Identity PTerm
pArg :: SyntaxInfo -> IParser PArg
pImplicitArg :: SyntaxInfo -> ParsecT String IState Identity (PArg' PTerm)
pConstraintArg :: SyntaxInfo -> ParsecT String IState Identity (PArg' PTerm)
pRecordType :: SyntaxInfo -> ParsecT String IState Identity PTerm
mkType :: Name -> Name
noImp :: SyntaxInfo -> SyntaxInfo
impOK :: SyntaxInfo -> SyntaxInfo
pTSig :: SyntaxInfo -> ParsecT String IState Identity PTerm
pTExpr :: SyntaxInfo -> ParsecT [Char] IState Identity PTerm
pLambda :: SyntaxInfo -> ParsecT String IState Identity PTerm
pLet :: SyntaxInfo -> ParsecT String IState Identity PTerm
pPi :: SyntaxInfo -> ParsecT String IState Identity PTerm
pConstList :: SyntaxInfo -> IParser [PTerm]
tyDeclList :: SyntaxInfo -> ParsecT [Char] IState Identity [(Name, PTerm)]
tyOptDeclList :: SyntaxInfo -> ParsecT [Char] IState Identity [(Name, PTerm)]
bindList :: (t -> t1 -> t2 -> t2) -> [(t, t1)] -> t2 -> t2
pComprehension :: SyntaxInfo -> ParsecT String IState Identity PTerm
pDoBlock :: SyntaxInfo -> ParsecT String IState Identity PTerm
pDo :: SyntaxInfo -> ParsecT String IState Identity (PDo' PTerm)
pIdiom :: SyntaxInfo -> ParsecT String IState Identity PTerm
pConstant :: IParser Const
pStatic :: IParser Static
table :: [FixDecl] -> [[Operator String IState Identity PTerm]]
toTable :: [FixDecl] -> [[Operator String IState Identity PTerm]]
binary :: String -> (FC -> a -> a -> a) -> Assoc -> Operator [Char] IState Identity a
prefix :: String -> (FC -> a -> a) -> Operator String IState Identity a
backtick :: Operator String IState Identity PTerm
accData :: Maybe Accessibility -> Name -> [Name] -> IParser ()
pRecord :: SyntaxInfo -> IParser PDecl
pDataI :: ParsecT String IState Identity Bool
pData :: SyntaxInfo -> IParser PDecl
bindArgs :: [PTerm] -> PTerm -> PTerm
pConstructor :: SyntaxInfo -> IParser (String, Name, PTerm, FC)
pSimpleCon :: SyntaxInfo -> IParser (String, Name, [PTerm], FC)
pDSL :: SyntaxInfo -> IParser PDecl
checkDSL :: DSL -> IParser ()
pOverload :: SyntaxInfo -> IParser (String, PTerm)
pPattern :: SyntaxInfo -> IParser PDecl
pCAF :: SyntaxInfo -> IParser PDecl
pArgExpr :: SyntaxInfo -> ParsecT String IState Identity PTerm
pRHS :: SyntaxInfo -> Name -> IParser PTerm
pClause :: SyntaxInfo -> IParser PClause
pWExpr :: SyntaxInfo -> IParser PTerm
pWhereblock :: Name -> SyntaxInfo -> IParser ([PDecl], [(Name, Name)])
pDirective :: IParser [PDecl]
pTactic :: SyntaxInfo -> IParser PTactic

module Idris.REPLParser
parseCmd :: IState -> [Char] -> Either ParseError Command

module Idris.Primitives
elabPrims :: Idris ()

module Idris.Prover
prover :: Bool -> Name -> Idris ()
showProof :: Bool -> Name -> [String] -> String
proverSettings :: ElabState [PDecl] -> Settings Idris
prove :: Context -> Bool -> Name -> Type -> Idris ()
elabStep :: ElabState [PDecl] -> ElabD a -> Idris (a, ElabState [PDecl])
dumpState :: IState -> ProofState -> IO ()
lifte :: ElabState [PDecl] -> ElabD a -> Idris a
ploop :: Bool -> String -> [String] -> ElabState [PDecl] -> Maybe History -> Idris (Term, [String])

module IRTS.LParser
type TokenParser a = TokenParser a
type LParser = GenParser Char ()
lexer :: TokenParser ()
whiteSpace :: ParsecT String () Identity ()
lexeme :: ParsecT String () Identity a -> ParsecT String () Identity a
symbol :: String -> ParsecT String () Identity String
natural :: ParsecT String () Identity Integer
parens :: ParsecT String () Identity a -> ParsecT String () Identity a
semi :: ParsecT String () Identity String
comma :: ParsecT String () Identity String
identifier :: ParsecT String () Identity String
reserved :: String -> ParsecT String () Identity ()
operator :: ParsecT String () Identity String
reservedOp :: String -> ParsecT String () Identity ()
integer :: ParsecT String () Identity Integer
float :: ParsecT String () Identity Double
strlit :: ParsecT String () Identity String
chlit :: ParsecT String () Identity Char
lchar :: Char -> ParsecT String () Identity Char
fovm :: Target -> OutputType -> FilePath -> IO ()
parseFOVM :: FilePath -> IO [(Name, LDecl)]
pProgram :: LParser [(Name, LDecl)]
pLDecl :: LParser (Name, LDecl)
pLExp :: GenParser Char () LExp
optable :: [[Operator Char () LExp]]
binary :: String -> (a -> a -> a) -> Assoc -> Operator Char () a
pLExp' :: LParser LExp
pLang :: ParsecT String () Identity FLang
pType :: ParsecT String () Identity FType
pCase :: LParser LExp
pCast :: LParser LExp
pPrim :: LParser LExp
pAlt :: LParser LAlt
pLConst :: LParser LExp

module Idris.REPL

-- | Run the REPL
repl :: IState -> [FilePath] -> InputT Idris ()

-- | The prompt consists of the currently loaded modules, or <a>Idris</a>
--   if there are none
mkPrompt :: [FilePath] -> [Char]

-- | Determine whether a file uses literate syntax
lit :: FilePath -> Bool
processInput :: String -> IState -> [FilePath] -> Idris (Maybe [FilePath])
resolveProof :: Name -> Idris Name
removeProof :: Name -> Idris ()
edit :: FilePath -> IState -> Idris ()
proofs :: IState -> Idris ()
insertScript :: String -> [String] -> [String]
process :: FilePath -> Command -> Idris ()
classInfo :: ClassInfo -> Idris ()
dumpMethod :: (Name, (FnOpts, PTerm)) -> Idris ()
dumpInstance :: Name -> Idris ()
showTotal :: Totality -> IState -> [Char]
showTotalN :: IState -> Name -> String
displayHelp :: [Char]
parseTarget :: String -> Target
parseArgs :: [String] -> [Opt]
help :: [([[Char]], [Char], [Char])]
replSettings :: Settings Idris
idris :: [Opt] -> IO IState
idrisMain :: [Opt] -> Idris ()
getFile :: Opt -> Maybe String
getBC :: Opt -> Maybe String
getFOVM :: Opt -> Maybe String
getOutput :: Opt -> Maybe String
getNewOutput :: Opt -> Maybe String
getIBCSubDir :: Opt -> Maybe String
getImportDir :: Opt -> Maybe String
getPkgDir :: Opt -> Maybe String
getPkg :: Opt -> Maybe (Bool, String)
getPkgClean :: Opt -> Maybe String
getTarget :: Opt -> Maybe Target
getOutputTy :: Opt -> Maybe OutputType
opt :: (Opt -> Maybe a) -> [Opt] -> [a]
ver :: String
banner :: [Char]

module Pkg.PParser
type TokenParser a = TokenParser a
type PParser = GenParser Char PkgDesc
lexer :: TokenParser PkgDesc
whiteSpace :: ParsecT String PkgDesc Identity ()
lexeme :: ParsecT String PkgDesc Identity a -> ParsecT String PkgDesc Identity a
symbol :: String -> ParsecT String PkgDesc Identity String
natural :: ParsecT String PkgDesc Identity Integer
parens :: ParsecT String PkgDesc Identity a -> ParsecT String PkgDesc Identity a
semi :: ParsecT String PkgDesc Identity String
comma :: ParsecT String PkgDesc Identity String
identifier :: ParsecT String PkgDesc Identity String
reserved :: String -> ParsecT String PkgDesc Identity ()
operator :: ParsecT String PkgDesc Identity String
reservedOp :: String -> ParsecT String PkgDesc Identity ()
integer :: ParsecT String PkgDesc Identity Integer
float :: ParsecT String PkgDesc Identity Double
strlit :: ParsecT String PkgDesc Identity String
chlit :: ParsecT String PkgDesc Identity Char
lchar :: Char -> ParsecT String PkgDesc Identity Char
data PkgDesc
PkgDesc :: String -> [String] -> [String] -> Maybe String -> [Opt] -> String -> [Name] -> Name -> Maybe String -> PkgDesc
pkgname :: PkgDesc -> String
libdeps :: PkgDesc -> [String]
objs :: PkgDesc -> [String]
makefile :: PkgDesc -> Maybe String
idris_opts :: PkgDesc -> [Opt]
sourcedir :: PkgDesc -> String
modules :: PkgDesc -> [Name]
idris_main :: PkgDesc -> Name
execout :: PkgDesc -> Maybe String
defaultPkg :: PkgDesc
parseDesc :: FilePath -> IO PkgDesc
pPkg :: PParser PkgDesc
pClause :: PParser ()
instance Show PkgDesc

module Pkg.Package
buildPkg :: Bool -> (Bool, FilePath) -> IO ()
cleanPkg :: FilePath -> IO ()
installPkg :: PkgDesc -> IO ()
buildMods :: [Opt] -> [Name] -> IO ()
testLib :: Bool -> String -> String -> IO Bool
rmIBC :: Name -> IO ()
toIBCFile :: Name -> [Char]
installIBC :: String -> Name -> IO ()
installObj :: String -> String -> IO ()
mkDirCmd :: [Char]
make :: Maybe String -> IO ()
clean :: Maybe String -> IO ()

module Main
main :: IO IState
runIdris :: [Opt] -> Idris ()
usage :: IO b
showver :: IO b
showLibs :: IO b
showLibdir :: IO b
showIncs :: IO b
usagemsg :: [Char]
